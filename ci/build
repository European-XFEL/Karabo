#!/usr/bin/env bash

set -e
set -o pipefail

if [ "${KARABO_UPLOAD_HOST}" == "" ]; then
    KARABO_UPLOAD_HOST=xkarabo@exflctrl01
fi
if [ "${KARABO_UPLOAD_DIR}" == "" ]; then
    KARABO_UPLOAD_DIR=/var/www/html/karabo
fi
if [ "${KARABO_UPLOAD_CURL_PREFIX}" == "" ]; then
    KARABO_UPLOAD_CURL_PREFIX=http://exflctrl01.desy.de/karabo
fi


SSH_PREFIX=$KARABO_UPLOAD_HOST:$KARABO_UPLOAD_DIR
LATEST_RELEASE_TAG=latest_build
LATEST_PRERELEASE_TAG=latest_prerelease_build
NIGHTLY_TAG=Nightly


__check_existence() {
    local status=$(curl --silent --head -r 0-0 "$1" | head -n 1)
    local fileNotFound=$(echo $status | grep 404)
    if [ -z "$fileNotFound" -a "$REL_TAG" != "Nightly" ]; then
        echo "That build exists already!"
        exit 1
    fi
}

__tests_build() {
    bash ./auto_build_all.sh Debug --numJobs $NUM_COMPILE_JOBS --buildAllTests
}

__release_build() {
    case "$2" in
        nightly)
            # nightly jobs are triggered on *ALL* schedules, due to
            # gitlab CI limitations.
            # In order to avoid running nightly on unrelated schedules,
            # we add a variable to each scheduled pipeline `SCHEDULED_JOB`
            # if this does not matches, we skip the whole nightly
            # task.
            # The only drawback, is that all jobs will appear as successful
            # even though they are skipped.
            if [[ "$CI_PIPELINE_SOURCE" == "schedule" && "$SCHEDULED_JOB" != "nightly-build" ]]; then
                # another scheduled job was triggered
                echo "Not a 'nightly-build' job. Skipping."
                exit 0
            fi
            export REL_TAG=$NIGHTLY_TAG
            export FRAMEWORK_DEST_DIR=karaboFramework/nightly
            export GUI_DEST_DIR=$FRAMEWORK_DEST_DIR
            ;;
        release)
            export REL_TAG=$CI_COMMIT_REF_NAME
            export FRAMEWORK_DEST_DIR=karaboFramework/tags/$REL_TAG
            export FRAMEWORK_LATEST_DIR=karaboFramework/tags/$LATEST_RELEASE_TAG
            export LATEST_TAG=$LATEST_RELEASE_TAG
            export GUI_DEST_DIR=karaboGui
            ;;
        prerelease)
            export REL_TAG=$CI_COMMIT_REF_NAME
            export FRAMEWORK_DEST_DIR=karaboFramework/tags/$REL_TAG
            export FRAMEWORK_LATEST_DIR=karaboFramework/tags/$LATEST_PRERELEASE_TAG
            export LATEST_TAG=$LATEST_PRERELEASE_TAG
            export GUI_DEST_DIR=karaboGui
            ;;
        *) echo "unknown job type: $2" ;;
    esac

    case "$1" in
        debian*|ubuntu*|centos*|almalinux*)
            export REL_OS_NAME=$LSB_RELEASE_DIST
            export REL_OS_VERS_LONG=$(echo $LSB_RELEASE_VERSION | sed -r "s/^([0-9]+).*/\1/")
            export REL_ARTIFACT_NAME=karabo-$REL_TAG-Release-$REL_OS_NAME-$REL_OS_VERS_LONG-x86_64.sh
            export REL_LATEST_NAME=karabo-$LATEST_TAG-Release-$REL_OS_NAME-$REL_OS_VERS_LONG-x86_64.sh
            export REL_ARTIFACT_DEST_PATH=$FRAMEWORK_DEST_DIR/$REL_ARTIFACT_NAME
            export REL_ARTIFACT_LATEST_PATH=$FRAMEWORK_LATEST_DIR/$REL_LATEST_NAME
            __check_existence $KARABO_UPLOAD_CURL_PREFIX/$FRAMEWORK_DEST_DIR/$REL_ARTIFACT_NAME
            bash ./auto_build_all.sh Release --numJobs $NUM_COMPILE_JOBS --bundle
            mv package/Release/$REL_OS_NAME/$REL_OS_VERS_LONG/x86_64/karabo-*.sh $REL_ARTIFACT_NAME
            # test that python is linked correctly in the archive
            # first relocate the extern dir to assure it is not picked up if we build in the same
            # job
            echo "Installing binary to perform final tests..."
            mv extern extern_will_not_link
            bash $REL_ARTIFACT_NAME --prefix=/tmp/
            source /tmp/karabo/activate
            # if any linker paths are off, the following commands will fail
            echo "Testing Python linking works by outputting version..."
            echo "python ..."
            python --version
            echo "python3 ..."
            python3 --version
            # echo "python3.8 ..."
            # python3.8 --version
            sshpass -p "$XKARABO_PWD" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $KARABO_UPLOAD_HOST "mkdir -p $KARABO_UPLOAD_DIR/$FRAMEWORK_DEST_DIR"
            sshpass -p "$XKARABO_PWD" scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $REL_ARTIFACT_NAME $SSH_PREFIX/$FRAMEWORK_DEST_DIR
            ;;
        *)
            echo "unknown target OS: $1"
            exit 1
            ;;
    esac

    if [ "$REL_TAG" != "$NIGHTLY_TAG" ]; then
        sshpass -p "$XKARABO_PWD" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $KARABO_UPLOAD_HOST "ln -fs $KARABO_UPLOAD_DIR/$REL_ARTIFACT_DEST_PATH $KARABO_UPLOAD_DIR/$REL_ARTIFACT_LATEST_PATH"
    fi
}

__deps_build() {
    pushd extern
    export DEPS_BASE_NAME=$LSB_RELEASE_DIST-$(echo $LSB_RELEASE_VERSION | sed -r "s/^([0-9]+).*/\1/")
    export DEPS_DIR_ABS_PATH=$(pwd -P)/$DEPS_BASE_NAME
    bash build.sh -q $DEPS_BASE_NAME CI
    $DEPS_BASE_NAME/bin/python3 ./builder_path_replace.py --fix-links $DEPS_BASE_NAME/bin $DEPS_DIR_ABS_PATH __KARABO_CI_PATH__
    $DEPS_BASE_NAME/bin/python3 ./builder_path_replace.py $DEPS_BASE_NAME/lib $DEPS_DIR_ABS_PATH __KARABO_CI_PATH__
    bash build.sh -p $DEPS_BASE_NAME CI
    export PACKAGE_FILENAME=$DEPS_BASE_NAME-*.tar.gz
    # if in a merge request, rename the archive to the branch filename.
    # The build script will set the filename's suffix to the last dependencies tag.
    # CI_COMMIT_TAG is set on tag-triggered pipelines and
    # CI_MERGE_REQUEST_SOURCE_BRANCH_NAME is set on merge requests
    if [ "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" != "" ] && [ "$CI_COMMIT_TAG" == "" ]; then
        mv $DEPS_BASE_NAME-*.tar.gz $DEPS_BASE_NAME-$CI_COMMIT_REF_SLUG.tar.gz
        export PACKAGE_FILENAME=$DEPS_BASE_NAME-$CI_COMMIT_REF_SLUG.tar.gz
    fi
    sshpass -p "$XKARABO_PWD" scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $PACKAGE_FILENAME $SSH_PREFIX/karaboDevelopmentDeps/
}


echo "Start building job: {$1}"

JOB_SCOPE=$(echo $1 | cut -f1 -d' ')
JOB_TYPE=$(echo $1 | cut -f2 -d' ')
JOB_TYPE=${JOB_TYPE//:}
TARGET_OS=$(echo $1 | cut -f3 -d' ')
TARGET_OS=${TARGET_OS//[}
TARGET_OS=${TARGET_OS//]}

case "$JOB_SCOPE" in
    release) __release_build $TARGET_OS $JOB_SCOPE ;;
    prerelease) __release_build $TARGET_OS $JOB_SCOPE ;;
    nightly) __release_build $TARGET_OS $JOB_SCOPE ;;
    deps) __deps_build $JOB_TYPE ;;
    tests) __tests_build $JOB_TYPE ;;
    *) echo "unknown job scope: $JOB_SCOPE" ;;
esac
