import time
import datetime
from bisect import bisect
from collections import OrderedDict
import os.path as op

from guiqwt.plot import CurveWidget, PlotManager
from guiqwt.tools import SelectPointTool
from guiqwt.builder import make
import numpy
from PyQt4 import uic
from PyQt4.QtCore import Qt, QDateTime, QObject, QTimer, pyqtSignal, pyqtSlot
from PyQt4.QtGui import (QButtonGroup, QDateTimeEdit, QDialog, QHBoxLayout,
                         QIntValidator, QLabel, QLineEdit, QPushButton,
                         QVBoxLayout, QWidget)
from PyQt4.Qwt5.Qwt import (QwtPlot, QwtScaleDraw, QwtText,
                            QwtLinearScaleEngine, QwtScaleDiv)

from karabo.middlelayer import Simple, Timestamp
import karabo_gui.globals as krb_globals
from karabo_gui.util import SignalBlocker
from karabo_gui.widget import DisplayWidget

X_AXIS = "_x_axis_btns"
Y_AXIS = "_y_axis_btns"

ONE_WEEK = "One Week"
ONE_DAY = "One Day"
ONE_HOUR = "One Hour"
TEN_MINUTES = "Ten Minutes"
RESET = "Uptime"
HIDDEN = "Hidden"

FULL_RANGE = "Full Range"
DETAIL_RANGE = "Detail"


def get_start_end_date_time(selected_time_span):
    """ Return beginning and end date time for given ``selected_time_span``.
        If the ``selected_time_span`` is not supported ``None`` is returned.
    """
    current_date_time = QDateTime.currentDateTime()
    if selected_time_span == ONE_WEEK:
        # One week
        start_date_time = current_date_time.addDays(-7)
    elif selected_time_span == ONE_DAY:
        # One day
        start_date_time = current_date_time.addDays(-1)
    elif selected_time_span == ONE_HOUR:
        # One hour
        start_date_time = current_date_time.addSecs(-3600)
    elif selected_time_span == TEN_MINUTES:
        # Ten minutes
        start_date_time = current_date_time.addSecs(-600)
    else:
        return None, None

    return start_date_time, current_date_time


class _Generation(object):
    """ This holds a single generation of a Curve's data.
    """
    size = 200
    base = 10  # number of points to combine per generation

    def __init__(self):
        self.fill = 0
        self.xs = numpy.empty(self.size, dtype=float)
        self.ys = numpy.empty(self.size, dtype=float)

    def addPoint(self, x, y):
        self.xs[self.fill] = x
        self.ys[self.fill] = y
        self.fill += 1

        if self.fill == self.size:
            return self.reduceData()
        return None

    def reduceData(self):
        x = self.xs[:self.base].mean()
        y = self.ys[:self.base].mean()
        self.xs[:-self.base] = self.xs[self.base:]
        self.ys[:-self.base] = self.ys[self.base:]
        self.fill -= self.base
        return x, y


class Curve(QObject):
    """This holds the data for one curve

    The currently to be shown data is in self.x and self.y.
    Up to self.histsize it is filled with historical data, up to self.fill
    it is then filled with "current" data, meaning data that has been
    accumulated from the changes coming in.

    There is a second data structure, self.generations, which is a list of
    _Generation objects containing averaged data, always `base` points are
    averaged over and put into the next higher aggregated storage.

    Once the basic storage in self.x and self.y flows over, it gets replaced
    by the averaged data in self.generations.
    """
    genCount = 4
    spare = 100
    maxHistory = 500  # Limits amount of data from past
    sparsesize = 400
    minHistory = 100  # minimum number of points shown (if possible)

    def __init__(self, box, curve, parent):
        QObject.__init__(self, parent)
        self.curve = curve
        self.box = box
        self.generations = [_Generation() for i in range(self.genCount)]

        self.histsize = 0
        # Describes actual length of the x/y lists
        self.fill = 0
        arraysize = self.spare + sum([g.size for g in self.generations], 0)
        self.x = numpy.empty(arraysize, dtype=float)
        self.y = numpy.empty(arraysize, dtype=float)

        self.t0 = self.t1 = 0
        box.signalHistoricData.connect(self.onHistoricData)
        box.visibilityChanged.connect(self.onVisibilityChanged)

    def addPoint(self, value, timestamp):
        # Fill the generations data, possibly propagating averaged values
        point = (timestamp, value)
        for gen in reversed(self.generations):
            point = gen.addPoint(*point)
            if point is None:
                break

        # Fill the main data buffer
        self.x[self.fill] = timestamp
        self.y[self.fill] = value
        self.fill += 1

        # When the main buffer fills up, copy the generations data
        if self.fill == len(self.x):
            self.fill_current()
        self.update()

    def fill_current(self):
        pos = self.histsize
        for gen in self.generations:
            fill = gen.fill
            if fill == 0:
                continue
            self.x[pos:pos + fill] = gen.xs[:fill]
            self.y[pos:pos + fill] = gen.ys[:fill]
            pos += fill
        self.fill = pos

    def getPropertyHistory(self, t0, t1):
        # Avoid if not currently visible
        if self.box.visible < 1:
            return
        t0 = str(datetime.datetime.utcfromtimestamp(t0).isoformat())
        t1 = str(datetime.datetime.utcfromtimestamp(t1).isoformat())
        self.box.getPropertyHistory(t0, t1, self.maxHistory)

    def changeInterval(self, t0, t1):
        p0 = self.x[:self.fill].searchsorted(t0)
        p1 = self.x[:self.fill].searchsorted(t1)

        not_enough_data = (p1 - p0) < self.minHistory
        no_data = self.histsize == 0
        zoomed_out = self.histsize > self.sparsesize
        nearly_left_border = 0.9 * self.t0 + 0.1 * self.t1
        nearly_right_border = 0.1 * self.t0 + 0.9 * self.t1

        # Request history only needs to be done under certain circumstances
        if (no_data or (not_enough_data and zoomed_out) or
                (self.x[p0] > nearly_left_border) or
                (p1 < self.histsize and self.x[p1 - 1] < nearly_right_border)):
            self.getPropertyHistory(t0, t1)
        self.t0 = t0
        self.t1 = t1

    def update(self):
        """ Show the new data on screen """
        self.curve.set_data(self.x[:self.fill], self.y[:self.fill])

    @pyqtSlot(bool)
    def onVisibilityChanged(self, visible):
        if visible and self.t1 >= self.x[self.histsize]:
            self.getPropertyHistory(self.t0, self.t1)

    @pyqtSlot(object, object)
    def onHistoricData(self, box, data):
        if not data:
            return

        datasize = len(data)
        gensize = sum([g.size for g in self.generations], 0)
        arraysize = datasize + gensize + self.spare
        x = numpy.empty(arraysize, dtype=float)
        y = numpy.empty(arraysize, dtype=float)

        for i, d in enumerate(data):
            x[i] = Timestamp.fromHashAttributes(d['v', ...]).toTimestamp()
            y[i] = d["v"]

        p0 = self.x[:self.fill].searchsorted(self.t0)
        p1 = self.x[:self.fill].searchsorted(self.t1)
        np0 = x[:datasize].searchsorted(self.t0)
        np1 = x[:datasize].searchsorted(self.t1)

        if self.t1 == self.t0:
            # Prevent division by 0, otherwise self.curve.plot() is None
            return

        span = (self.x[p1 - 1] - self.x[p0]) / (self.t1 - self.t0)
        nspan = (x[np1 - 1] - x[np0]) / (self.t1 - self.t0)

        if (np1 - np0 < p1 - p0) and not nspan > span < 0.9:
            return

        # If the history overlaps generation data, favor the history data.
        end = x[datasize - 1]
        for gen in self.generations:
            fill = gen.fill
            if fill == 0:
                continue
            pos = gen.xs[:fill].searchsorted(end)
            if pos == 0:
                break
            gen.xs[:fill - pos] = gen.xs[pos:fill]
            gen.fill = fill - pos

        self.histsize = datasize
        self.x = x
        self.y = y
        self.fill_current()
        self.update()
        self.curve.plot().replot()

    def get_mean_y_value(self, count=10):
        """ Return mean value for last ``count`` of y values."""
        if count > len(self.y):
            count = len(self.y)
        return numpy.mean(self.y[max(self.fill-count, 0):self.fill])

    def get_min_y_value(self):
        """ Return min value of all y values."""
        return min(self.y[:self.fill])

    def get_max_y_value(self):
        """ Return max value for all y values"""
        return max(self.y[:self.fill])


class DateTimeScaleDraw(QwtScaleDraw):
        '''Class used to draw a datetime axis on our plot. '''
        formats = ((60, "%Y-%m-%d %H:%M", "%Ss"),
                   (60 * 60, "%Y-%m-%d", "%H:%M"),
                   (60 * 60 * 24, "%Y-%m-%d", "%Hh"),
                   (60 * 60 * 24 * 7, "%b %Y", "%d"),
                   (60 * 60 * 24 * 30, "%Y", "%d/%m"))

        def setFormat(self, start, ss):
            self.start = start
            for s, maj, min in self.formats:
                if ss < s:
                    break
            self.major = maj
            self.minor = min

        def label(self, value):
            '''create the text of each label to draw the axis. '''
            if value == self.start:
                fmt = self.minor + "\n" + self.major
            else:
                fmt = self.minor
            try:
                dt = datetime.datetime.fromtimestamp(value)
            except:
                dt = datetime.datetime.fromtimestamp(0)
            return QwtText(dt.strftime(fmt))


class ScaleEngine(QwtLinearScaleEngine):
    def __init__(self, drawer):
        super().__init__()
        self.drawer = drawer

    def divideScale(self, x1, x2, maxMajorSteps, maxMinorSteps, stepSize):
        ss = (x2 - x1) / maxMajorSteps
        a = [1, 2, 5, 10, 20, 60,
             60 * 2, 60 * 5, 60 * 10, 60 * 30, 60 * 60,
             3600 * 2, 3600 * 4, 3600 * 8, 3600 * 12, 3600 * 24,
             3600 * 24 * 2, 3600 * 24 * 4, 3600 * 24 * 7]
        pos = bisect(a, ss)
        if pos == len(a):
            v = a[-1]
            while v < ss:
                v *= 2
        else:
            v = a[pos]
        start = int(x1 // v + 1) * v
        self.drawer.setFormat(start, v)
        return QwtScaleDiv(x1, x2, [], [], list(range(start, int(x2), v)))


class Timespan(QDialog):
    def __init__(self, parent):
        super(Timespan, self).__init__(parent)
        uic.loadUi(op.join(op.dirname(__file__), "timespan.ui"), self)

    def _set_beginning_end_date_time(self, selected_time_span):
        start_dt, end_dt = get_start_end_date_time(selected_time_span)
        self.dt_beginning.setDateTime(start_dt)
        self.dt_end.setDateTime(end_dt)

    def on_pb_one_week_clicked(self):
        self._set_beginning_end_date_time(ONE_WEEK)

    def on_pb_one_day_clicked(self):
        self._set_beginning_end_date_time(ONE_DAY)

    def on_pb_one_hour_clicked(self):
        self._set_beginning_end_date_time(ONE_HOUR)

    def on_pb_ten_minutes_clicked(self):
        self._set_beginning_end_date_time(TEN_MINUTES)


class _KaraboCurveWidget(CurveWidget):
    signal_mouse_event = pyqtSignal()

    def __init__(self, **kwargs):
        """ Possible key arguments:
            * parent: parent widget
            * title: plot title
            * xlabel: (bottom axis title, top axis title) or bottom axis title only
            * ylabel: (left axis title, right axis title) or left axis title only
            * xunit: (bottom axis unit, top axis unit) or bottom axis unit only
            * yunit: (left axis unit, right axis unit) or left axis unit only
            * panels (optional): additionnal panels (list, tuple)
        """
        super(_KaraboCurveWidget, self).__init__(**kwargs)

    def mousePressEvent(self, event):
        if event.button() in (Qt.LeftButton, Qt.MidButton, Qt.RightButton):
            self.signal_mouse_event.emit()
        super(_KaraboCurveWidget, self).mousePressEvent(event)


class DisplayTrendline(DisplayWidget):
    category = Simple
    alias = "Trendline"

    style = "{text-align: center; font-size: 9px; padding: 0}"
    button_style_sheet = ("QPushButton {}".format(style))
    datetimeedit_style_sheet = ("QDateTimeEdit {}".format(style))
    lineedit_style_sheet = ("QLineEdit {}".format(style))

    curve_colors = ['k', 'g', 'b', 'pink', 'brown', 'orange']
    curve_styles = ['-', '--', ':', '-.']

    def __init__(self, box, parent):
        super(DisplayTrendline, self).__init__(None)
        self._initUI(parent)

        # Keep the initial start time to recover trendline for 'Reset'
        self.initial_start_time = QDateTime.currentDateTime()

        self.plot = self.curveWidget.get_plot()
        self.plot.set_antialiasing(True)
        self.plot.setAxisTitle(QwtPlot.xBottom, 'Time')

        # We are using CurveWidget, which internally creates a BaseCurveWidget,
        # which internally creates a CurvePlot, which contains the method
        # edit_axis_parameters, which creates the widget to set the time axis.
        # It would be a nightmare to overwrite three classes, so we just do
        # a little monkey patching here.
        self.plot.edit_axis_parameters = self.edit_axis_parameters

        # have a 1 s timeout to request data, thus avoid
        # frequent re-loading while scaling
        self.timer = QTimer(self)
        self.timer.setInterval(1000)
        self.timer.setSingleShot(True)
        self.plot.axisWidget(QwtPlot.xBottom).scaleDivChanged.connect(
            self.timer.start)
        self.timer.timeout.connect(self._x_axis_scale_changed)

        self.curves = {}

        self.manager = PlotManager(self)
        self.manager.add_plot(self.plot)

        self.manager.register_all_curve_tools()
        self.manager.register_other_tools()
        self.manager.add_tool(SelectPointTool, title='Test',
                              on_active_item=True, mode='create')

        drawer = DateTimeScaleDraw()
        self.plot.setAxisScaleEngine(QwtPlot.xBottom, ScaleEngine(drawer))
        self.plot.setAxisScaleDraw(QwtPlot.xBottom, drawer)
        self.plot.setAxisAutoScale(QwtPlot.yLeft)
        self.lasttime = time.time()
        self.wasVisible = False
        self.plot.setAxisScale(QwtPlot.xBottom,
                               round(time.time() - 1), round(time.time() + 10))
        self.plot.setAxisLabelAlignment(QwtPlot.xBottom,
                                        Qt.AlignRight | Qt.AlignBottom)
        self.destroyed.connect(self.destroy)
        self._curve_count = 0
        self.legend = None
        self.addBox(box)

    def _initUI(self, parent):
        """ Setup all widgets correctly.
        """
        self.curveWidget = _KaraboCurveWidget(parent=parent)
        # Make connection to update time buttons when mouse event in QwtWidget
        # happened
        self.curveWidget.signal_mouse_event.connect(self._uncheck_axis_buttons)

        # Init x-axis buttons
        # Create widget for beginning and end date time
        self.date_time_widget = QWidget()
        self.date_time_layout = QHBoxLayout(self.date_time_widget)
        self.date_time_layout.setContentsMargins(0, 0, 0, 0)

        current_date_time = QDateTime.currentDateTime()
        self.dt_start = QDateTimeEdit(current_date_time)
        self.dt_start.setDisplayFormat("yyyy-MM-dd hh:mm:ss")
        self.dt_start.setStyleSheet(self.datetimeedit_style_sheet)
        self.dt_end = QDateTimeEdit(current_date_time)
        self.dt_end.setDisplayFormat("yyyy-MM-dd hh:mm:ss")
        self.dt_end.setStyleSheet(self.datetimeedit_style_sheet)
        self.date_time_layout.addWidget(self.dt_start)
        self.date_time_layout.addWidget(self.dt_end)

        x_axis_btns_widget = QWidget()
        x_axis_btns_layout = QHBoxLayout(x_axis_btns_widget)
        x_axis_btns_layout.setContentsMargins(0, 0, 0, 0)

        self.x_axis_str_btns = OrderedDict()  # Map time str to QPushButton
        self.x_axis_str_btns[ONE_WEEK] = None
        self.x_axis_str_btns[ONE_DAY] = None
        self.x_axis_str_btns[ONE_HOUR] = None
        self.x_axis_str_btns[TEN_MINUTES] = None
        self.x_axis_str_btns[RESET] = None
        self.x_axis_btns = self._create_button_group(
            X_AXIS, self.x_axis_str_btns, x_axis_btns_layout)
        self._sel_x_axis_btn = None

        # Init y-axis buttons
        y_axis_buttons_widget = QWidget()
        y_axis_btns_layout = QHBoxLayout(y_axis_buttons_widget)
        y_axis_btns_layout.setContentsMargins(0, 0, 0, 0)

        self.y_axis_str_btns = OrderedDict()  # Map range str to QPushButton
        self.y_axis_str_btns[FULL_RANGE] = None
        self.y_axis_str_btns[DETAIL_RANGE] = None
        self.y_axis_btns = self._create_button_group(
            Y_AXIS, self.y_axis_str_btns, y_axis_btns_layout)

        self.leDetailRange = QLineEdit("10")
        self.leDetailRange.setMinimumWidth(30)
        self.leDetailRange.setMaximumWidth(80)
        self.leDetailRange.setEnabled(False)
        self.leDetailRange.setStyleSheet(self.lineedit_style_sheet)
        validator = QIntValidator(1, krb_globals.MAX_INT32)
        self.leDetailRange.setValidator(validator)
        self.leDetailRange.textChanged.connect(self._detail_range_changed)
        self.laDetailRange = QLabel("%")

        y_axis_btns_layout.addWidget(self.y_axis_str_btns[DETAIL_RANGE])
        y_axis_btns_layout.addWidget(self.leDetailRange)
        y_axis_btns_layout.addWidget(self.laDetailRange)

        yLayout = QVBoxLayout()
        yLayout.addWidget(self.y_axis_str_btns[FULL_RANGE])
        yLayout.addWidget(y_axis_buttons_widget)
        yLayout.addStretch()
        self._sel_y_axis_btn = None

        xLayout = QVBoxLayout()
        xLayout.addWidget(self.curveWidget)
        xLayout.addWidget(self.date_time_widget)
        xLayout.addWidget(x_axis_btns_widget)

        self.widget = QWidget()
        self.layout = QHBoxLayout(self.widget)
        self.layout.addLayout(yLayout)
        self.layout.addLayout(xLayout)

    def edit_axis_parameters(self, axis_id):
        if axis_id != QwtPlot.xBottom:
            # call the original method that we monkey-patched over
            type(self.plot).edit_axis_parameters(self.plot, axis_id)
        else:
            dialog = Timespan(self.curveWidget)
            sd = self.plot.axisScaleDiv(QwtPlot.xBottom)
            dialog.dt_beginning.setDateTime(
                QDateTime.fromMSecsSinceEpoch(sd.lowerBound() * 1000))
            dialog.dt_end.setDateTime(
                QDateTime.fromMSecsSinceEpoch(sd.upperBound() * 1000))
            if dialog.exec_() != dialog.Accepted:
                return
            # Reset time buttons
            self._uncheck_axis_buttons()
            start_date_time = dialog.dt_beginning.dateTime()
            end_date_time = dialog.dt_end.dateTime()
            start_secs = start_date_time.toMSecsSinceEpoch() / 1000
            end_secs = end_date_time.toMSecsSinceEpoch() / 1000
            self.plot.setAxisScale(QwtPlot.xBottom, start_secs, end_secs)
            self.updateLater()

    def typeChanged(self, box):
        self.plot.setAxisTitle(QwtPlot.yLeft, box.axisLabel())

    def _getNewCurveColorAndStyle(self):
        """ Return a combination of color and style for the next curve

        Will continue to return unique color style combinations until
        len(self.curve_colors) * len(self.curve_styles) curves have been
        added, then wrap around
        """
        n_colors =  len(self.curve_colors)
        color_idx = self._curve_count % n_colors
        style_idx = (self._curve_count // n_colors) % len(self.curve_styles)
        self._curve_count += 1
        return self.curve_colors[color_idx], self.curve_styles[style_idx]

    def addBox(self, box):
        color, style = self._getNewCurveColorAndStyle()
        curve = make.curve([], [], box.key(), color=color, linestyle=style)
        self._addCurve(box, curve)
        if self._curve_count == 2:
            # show the item panel if we have more than on curve
            self.curveWidget.get_itemlist_panel().show()
            # also show a legend
            self.legend = make.legend("TL")
            self.plot.add_item(self.legend)
        return True

    @pyqtSlot(object)
    def destroy(self):
        for box in self.curves:
            box.removeVisible()

    value = None

    def removeKey(self, key):
        # XXX: This appears to be dead code!
        # If it's not, there will be problems keeping data models synchronized
        # with the state of this widget (specifically, the refactored scene).
        self.plot.remove_item(self.curves[key])
        del self.curves[key]
        key.removeVisible()

    @property
    def boxes(self):
        return list(self.curves)

    def valueChanged(self, box, value, timestamp=None):
        if timestamp is None:
            return

        t = timestamp.toTimestamp()
        self.curves[box].addPoint(value, t)

        t0 = self.plot.axisScaleDiv(QwtPlot.xBottom).lowerBound()
        t1 = self.plot.axisScaleDiv(QwtPlot.xBottom).upperBound()
        if self.lasttime < t1 < t:
            if not self._update_x_axis_scale():
                aw = self.plot.axisWidget(QwtPlot.xBottom)
                with SignalBlocker(aw):
                    self.plot.setAxisScale(QwtPlot.xBottom, t0, t + 10)

        self.lasttime = timestamp.toTimestamp()
        self.wasVisible = True
        self.updateLater()

    def deferredUpdate(self):
        self.plot.replot()
        asd = self.plot.axisScaleDiv(QwtPlot.xBottom)
        t0, t1 = asd.lowerBound(), asd.upperBound()
        # Update date time widgets
        start = QDateTime.fromMSecsSinceEpoch(t0 * 1000)
        end = QDateTime.fromMSecsSinceEpoch(t1 * 1000)
        self._update_date_time_widgets(start, end)

    @pyqtSlot()
    def _x_axis_scale_changed(self):
        """ This slot is called whenever the timer timed out and previously the
            x axis scale was changed. """
        asd = self.plot.axisScaleDiv(QwtPlot.xBottom)
        t0, t1 = asd.lowerBound(), asd.upperBound()
        self._update_x_axis_interval(t0, t1)
        self._update_y_axis_scale()

    @pyqtSlot(str)
    def _detail_range_changed(self, text):
        if self._update_y_axis_scale():
            self.updateLater()

    @pyqtSlot(object)
    def _y_axis_btns_toggled(self, button):
        self._sel_y_axis_btn = button
        if self._update_y_axis_scale():
            self.updateLater()

    @pyqtSlot(object)
    def _x_axis_btns_toggled(self, button):
        """ A time button was clicked which needs to update the axis scale. """
        self._sel_x_axis_btn = button
        if self._update_x_axis_scale():
            self.updateLater()

    @pyqtSlot()
    def _reset_button_clicked(self):
        """ Reset the x axis scale to the initial start time."""
        self._uncheck_axis_buttons()

        start_date_time = self.initial_start_time
        end_date_time = QDateTime.currentDateTime()

        start_secs = start_date_time.toMSecsSinceEpoch() / 1000
        end_secs = end_date_time.toMSecsSinceEpoch() / 1000
        # Rescale x axis
        self.plot.setAxisScale(QwtPlot.xBottom, start_secs, end_secs)
        self.updateLater()

    @pyqtSlot()
    def _uncheck_axis_buttons(self):
        """ No axis button should be selected.
            To realize that a ``HIDDEN`` button of the button groups is clicked
            and the selected x/y axis button is set to ``None``.
        """
        if self._sel_x_axis_btn is None and self._sel_y_axis_btn is None:
            return

        # x axis related buttons
        self.x_axis_str_btns[HIDDEN].click()
        self._sel_x_axis_btn = None

        # y axis related buttons
        self.y_axis_str_btns[HIDDEN].click()
        self._sel_y_axis_btn = None

    # ----------------------------
    # Private methods

    def _addCurve(self, box, curve):
        """ Give derived classes a place to respond to changes. """
        if box in self.curves:
            old_curve = self.curves[box]
            self.plot.del_item(old_curve.curve)
        if not isinstance(curve, Curve):
            curve = Curve(box, curve, self.curveWidget)
        self.curves[box] = curve
        self.plot.add_item(curve.curve)
        curve.update()

    def _create_button_group(self, button_type, string_btn_dict, layout):
        """ The buttons for time/range scaling are created.
        """
        button_group = QButtonGroup()
        button_group.buttonClicked.connect(
            getattr(self, "{}_toggled".format(button_type)))

        for btn_text in string_btn_dict.keys():
            button = QPushButton(btn_text)
            button.setStyleSheet(self.button_style_sheet)
            string_btn_dict[btn_text] = button
            if btn_text == RESET:
                button.clicked.connect(self._reset_button_clicked)
            else:
                # Do not add reset button to button group
                button.setCheckable(True)
                button_group.addButton(button)

            # Different layout used for y axis buttons
            if button_type == X_AXIS:
                layout.addWidget(button)

        # Add invisible button to get the state that no buttons are visible
        hidden_btn = QPushButton()
        hidden_btn.setCheckable(True)
        hidden_btn.setVisible(False)
        string_btn_dict[HIDDEN] = hidden_btn
        button_group.addButton(hidden_btn, 0)
        layout.addWidget(hidden_btn)

        return button_group

    def _update_x_axis_interval(self, t0, t1):
        """ Update lower and upper bound of curve intervals. """
        for v in self.curves.values():
            v.changeInterval(t0, t1)

    def _update_date_time_widgets(self, start, end):
        """ The date time widgets get updated to the corresponding x axis
            scale.
        """
        self.dt_start.setDateTime(start)
        self.dt_end.setDateTime(end)

    def _update_x_axis_scale(self):
        """ The start and end time date for the x axis is updated here
            depending on the selected time button.
            In case of success ``True`` is returned, else ``False``."""
        if self._sel_x_axis_btn is None:
            return False

        start, end = get_start_end_date_time(self._sel_x_axis_btn.text())

        if start is None or end is None:
            return False

        start_secs = start.toMSecsSinceEpoch() / 1000
        end_secs = end.toMSecsSinceEpoch() / 1000

        # Rescale x axis
        aw = self.plot.axisWidget(QwtPlot.xBottom)
        with SignalBlocker(aw):
            # Use blocker to prevent timer start
            self.plot.setAxisScale(QwtPlot.xBottom, start_secs, end_secs)
        self._update_x_axis_interval(start_secs, end_secs)
        return True

    def _update_y_axis_scale(self):
        """ The minimum and maximum value for the y axis is updated depending
            on the selected range button.
            In case of success ``True`` is returned, else ``False``.
        """
        if self._sel_y_axis_btn is None:
            return False

        if self._sel_y_axis_btn.text() == FULL_RANGE:
            # Reset
            self.leDetailRange.setEnabled(False)
            ymin = krb_globals.MAX_INT32
            ymax = -ymin
            for curve in self.curves.values():
                min_y = curve.get_min_y_value()
                if ymin > min_y:
                    ymin = min_y
                max_y = curve.get_max_y_value()
                if ymax < max_y:
                    ymax = max_y
        elif self._sel_y_axis_btn.text() == DETAIL_RANGE:
            # Calculate mean of last 10 values and use detail range value to
            # get ymin/ymax
            self.leDetailRange.setEnabled(True)
            y_mean_values = []
            for curve in self.curves.values():
                y_mean = curve.get_mean_y_value()
                y_mean_values.append(y_mean)
            y_mean = numpy.mean(y_mean_values)
            y_range = y_mean * int(self.leDetailRange.text()) * 0.01
            ymin = y_mean - y_range
            ymax = y_mean + y_range
        else:
            return False

        # Rescale y axis
        aw = self.plot.axisWidget(QwtPlot.yLeft)
        with SignalBlocker(aw):
            self.plot.setAxisScale(QwtPlot.yLeft, ymin, ymax)
        return True
