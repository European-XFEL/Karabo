macro (resolveKaraboLibTarget)

    if (NOT TARGET ${KARABO_LIB_TARGET_NAME})
        # The Karabo Framework Lib is not a known target.
        # set(CMAKE_FIND_DEBUG_MODE TRUE)
        find_library(KARABO_LIB ${KARABO_LIB_TARGET_NAME})
        # set(CMAKE_FIND_DEBUG_MODE FALSE)
        # message(STATUS "KARABO_LIB = ${KARABO_LIB}")
        get_filename_component(KARABO_LIB_DIR ${KARABO_LIB} DIRECTORY)
        # message(STATUS "KARABO_LIB_DIR = ${KARABO_LIB_DIR}")
        if ("${KARABO_LIB_DIR}" STREQUAL "${CMAKE_PREFIX_PATH}/lib")
            # The lib could be found at a standard install location in the current ${CMAKE_PREFIX_PATH}.
            # This means it has been installed in the current cmake build environment, be it a Conda Env,
            # a Docker image or a full system. We go ahead by "synthesizing" an imported target for the
            # library. We try this before using the standard export package generated by the lib project
            # install because the export package won't work for a Conda Env (it will contain paths of the
            # temporary conda-bld work environment, not the paths for the Conda environment where the
            # package has been installed).
            add_library(${KARABO_LIB_TARGET_NAME} SHARED IMPORTED)
            # Note: the Include Directories properties are fixed and expressed in terms of
            #       CMAKE_PREFIX_PATH. This is intentional as those directories are "stable"
            #       (header files of library dependencies will "converge" to them and this
            #       relocatable form based on CMAKE_PREFIX_PATH is more generic than the
            #       one generated dynamically, which would depend on the installation path
            #       resolved by CMake at configuration time.
            set_target_properties(${KARABO_LIB_TARGET_NAME} PROPERTIES
                INTERFACE_COMPILE_DEFINITIONS "__SO__"
                INTERFACE_COMPILE_OPTIONS "-Wfatal-errors;-Wno-unused-local-typedefs;-Wno-deprecated-declarations;-Wall"
                INTERFACE_INCLUDE_DIRECTORIES "${CMAKE_PREFIX_PATH}/include/karabo;${CMAKE_PREFIX_PATH}/include;${CMAKE_PREFIX_PATH}/include/hdf5"
                INTERFACE_LINK_LIBRARIES "${CMAKE_PREFIX_PATH}/lib/libboost_filesystem.so;${CMAKE_PREFIX_PATH}/lib/libboost_system.so;${CMAKE_PREFIX_PATH}/lib/libboost_chrono.so;${CMAKE_PREFIX_PATH}/lib/libboost_date_time.so;${CMAKE_PREFIX_PATH}/lib/libboost_regex.so;${CMAKE_PREFIX_PATH}/lib/libboost_thread.so;${CMAKE_PREFIX_PATH}/lib/libhdf5.so;/usr/lib/x86_64-linux-gnu/libpthread.so;/usr/lib/x86_64-linux-gnu/libz.so;/usr/lib/x86_64-linux-gnu/libdl.so;/usr/lib/x86_64-linux-gnu/libm.so;/usr/lib/x86_64-linux-gnu/libssl.so;/usr/lib/x86_64-linux-gnu/libcrypto.so;${CMAKE_PREFIX_PATH}/lib/libopenmqc.so;${CMAKE_PREFIX_PATH}/lib/libamqpcpp.so;${CMAKE_PREFIX_PATH}/lib/liblog4cpp.so;${CMAKE_PREFIX_PATH}/lib/libpugixml.so"
                INTERFACE_SYSTEM_INCLUDE_DIRECTORIES "${CMAKE_PREFIX_PATH}/include"
            )
            set_target_properties(${KARABO_LIB_TARGET_NAME} PROPERTIES
                IMPORTED_LOCATION ${KARABO_LIB}
            )
        else ()
            # Try to use the export package generated by the lib project install. The name of the package,
            # "karaboLib", must match the name of the export install target in the Framework Lib CMake
            # project. The hinted path is the DESTINATION of that same export install target in the
            # Framework Lib CMake project.
            # set(CMAKE_FIND_DEBUG_MODE TRUE)
            find_package(
                "karaboLib" REQUIRED
                HINTS "${CMAKE_PREFIX_PATH}/lib/cmake"
            )
            # set(CMAKE_FIND_DEBUG_MODE FALSE)
        endif()
    endif()

endmacro()
