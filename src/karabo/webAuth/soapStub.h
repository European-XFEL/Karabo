/* soapStub.h
   Generated by gSOAP 2.8.14 from ClientAuthentication.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
 */

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns2	""
#define SOAP_NAMESPACE_OF_ns1	"http://server.xfelauthwebservice.xfel.eu/"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20814
#error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__getUserNonce
#define SOAP_TYPE_ns1__getUserNonce (8)

/* ns1:getUserNonce */
class SOAP_CMAC ns1__getUserNonce {

public:
    std::string *username; /* optional element of type xsd:string */
    std::string *provider; /* optional element of type xsd:string */
    std::string *ipAddress; /* optional element of type xsd:string */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 8;
    } /* = unique id SOAP_TYPE_ns1__getUserNonce */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__getUserNonce() {
        ns1__getUserNonce::soap_default(NULL);
    }

    virtual ~ns1__getUserNonce() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__getUserNonceResponse
#define SOAP_TYPE_ns1__getUserNonceResponse (9)

/* ns1:getUserNonceResponse */
class SOAP_CMAC ns1__getUserNonceResponse {

public:
    class ns1__xfelSession *return_; /* SOAP 1.2 RPC return element (when namespace qualified) */ /* optional element of type ns1:xfelSession */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 9;
    } /* = unique id SOAP_TYPE_ns1__getUserNonceResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__getUserNonceResponse() {
        ns1__getUserNonceResponse::soap_default(NULL);
    }

    virtual ~ns1__getUserNonceResponse() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__xfelSession
#define SOAP_TYPE_ns1__xfelSession (10)

/* ns1:xfelSession */
class SOAP_CMAC ns1__xfelSession {

public:
    std::string *accessList; /* optional element of type xsd:string */
    std::string *defaultAccessLevelDesc; /* optional element of type xsd:string */
    int *defaultAccessLevelId; /* optional element of type xsd:int */
    std::string *familyName; /* optional element of type xsd:string */
    std::string *firstName; /* optional element of type xsd:string */
    std::string *operationResultMsg; /* optional element of type xsd:string */
    int *operationSuccess; /* optional element of type xsd:int */
    std::string *provider; /* optional element of type xsd:string */
    std::string *sessionToken; /* optional element of type xsd:string */
    std::string *softwareDesc; /* optional element of type xsd:string */
    LONG64 *softwareId; /* optional element of type xsd:long */
    LONG64 *userId; /* optional element of type xsd:long */
    std::string *username; /* optional element of type xsd:string */
    std::string *welcomeMessage; /* optional element of type xsd:string */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 10;
    } /* = unique id SOAP_TYPE_ns1__xfelSession */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__xfelSession() {
        ns1__xfelSession::soap_default(NULL);
    }

    virtual ~ns1__xfelSession() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__sessionsByIp
#define SOAP_TYPE_ns1__sessionsByIp (11)

/* ns1:sessionsByIp */
class SOAP_CMAC ns1__sessionsByIp {

public:
    std::string *ipAddress; /* optional element of type xsd:string */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 11;
    } /* = unique id SOAP_TYPE_ns1__sessionsByIp */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__sessionsByIp() {
        ns1__sessionsByIp::soap_default(NULL);
    }

    virtual ~ns1__sessionsByIp() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__sessionsByIpResponse
#define SOAP_TYPE_ns1__sessionsByIpResponse (12)

/* ns1:sessionsByIpResponse */
class SOAP_CMAC ns1__sessionsByIpResponse {

public:
    std::string *return_; /* SOAP 1.2 RPC return element (when namespace qualified) */ /* optional element of type xsd:string */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 12;
    } /* = unique id SOAP_TYPE_ns1__sessionsByIpResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__sessionsByIpResponse() {
        ns1__sessionsByIpResponse::soap_default(NULL);
    }

    virtual ~ns1__sessionsByIpResponse() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__logout
#define SOAP_TYPE_ns1__logout (13)

/* ns1:logout */
class SOAP_CMAC ns1__logout {

public:
    std::string *username; /* optional element of type xsd:string */
    std::string *provider; /* optional element of type xsd:string */
    std::string *sessionToken; /* optional element of type xsd:string */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 13;
    } /* = unique id SOAP_TYPE_ns1__logout */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__logout() {
        ns1__logout::soap_default(NULL);
    }

    virtual ~ns1__logout() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__logoutResponse
#define SOAP_TYPE_ns1__logoutResponse (14)

/* ns1:logoutResponse */
class SOAP_CMAC ns1__logoutResponse {

public:
    bool *return_; /* SOAP 1.2 RPC return element (when namespace qualified) */ /* optional element of type xsd:boolean */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 14;
    } /* = unique id SOAP_TYPE_ns1__logoutResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__logoutResponse() {
        ns1__logoutResponse::soap_default(NULL);
    }

    virtual ~ns1__logoutResponse() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__singleSignOn
#define SOAP_TYPE_ns1__singleSignOn (15)

/* ns1:singleSignOn */
class SOAP_CMAC ns1__singleSignOn {

public:
    std::string *username; /* optional element of type xsd:string */
    std::string *provider; /* optional element of type xsd:string */
    std::string *ipAddress; /* optional element of type xsd:string */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 15;
    } /* = unique id SOAP_TYPE_ns1__singleSignOn */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__singleSignOn() {
        ns1__singleSignOn::soap_default(NULL);
    }

    virtual ~ns1__singleSignOn() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__singleSignOnResponse
#define SOAP_TYPE_ns1__singleSignOnResponse (16)

/* ns1:singleSignOnResponse */
class SOAP_CMAC ns1__singleSignOnResponse {

public:
    ns1__xfelSession *return_; /* SOAP 1.2 RPC return element (when namespace qualified) */ /* optional element of type ns1:xfelSession */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 16;
    } /* = unique id SOAP_TYPE_ns1__singleSignOnResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__singleSignOnResponse() {
        ns1__singleSignOnResponse::soap_default(NULL);
    }

    virtual ~ns1__singleSignOnResponse() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__hasActiveSession
#define SOAP_TYPE_ns1__hasActiveSession (17)

/* ns1:hasActiveSession */
class SOAP_CMAC ns1__hasActiveSession {

public:
    std::string *username; /* optional element of type xsd:string */
    std::string *provider; /* optional element of type xsd:string */
    std::string *software; /* optional element of type xsd:string */
    std::string *ipAddress; /* optional element of type xsd:string */
    std::string *brokerHostname; /* optional element of type xsd:string */
    std::string *brokerPortNumber; /* optional element of type xsd:string */
    std::string *brokerTopic; /* optional element of type xsd:string */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 17;
    } /* = unique id SOAP_TYPE_ns1__hasActiveSession */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__hasActiveSession() {
        ns1__hasActiveSession::soap_default(NULL);
    }

    virtual ~ns1__hasActiveSession() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__hasActiveSessionResponse
#define SOAP_TYPE_ns1__hasActiveSessionResponse (18)

/* ns1:hasActiveSessionResponse */
class SOAP_CMAC ns1__hasActiveSessionResponse {

public:
    bool *return_; /* SOAP 1.2 RPC return element (when namespace qualified) */ /* optional element of type xsd:boolean */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 18;
    } /* = unique id SOAP_TYPE_ns1__hasActiveSessionResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__hasActiveSessionResponse() {
        ns1__hasActiveSessionResponse::soap_default(NULL);
    }

    virtual ~ns1__hasActiveSessionResponse() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__login
#define SOAP_TYPE_ns1__login (19)

/* ns1:login */
class SOAP_CMAC ns1__login {

public:
    std::string *username; /* optional element of type xsd:string */
    std::string *password; /* optional element of type xsd:string */
    std::string *provider; /* optional element of type xsd:string */
    std::string *ipAddress; /* optional element of type xsd:string */
    std::string *brokerHostname; /* optional element of type xsd:string */
    std::string *brokerPortNumber; /* optional element of type xsd:string */
    std::string *brokerTopic; /* optional element of type xsd:string */
    std::string *nonce; /* optional element of type xsd:string */
    std::string *software; /* optional element of type xsd:string */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 19;
    } /* = unique id SOAP_TYPE_ns1__login */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__login() {
        ns1__login::soap_default(NULL);
    }

    virtual ~ns1__login() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__loginResponse
#define SOAP_TYPE_ns1__loginResponse (20)

/* ns1:loginResponse */
class SOAP_CMAC ns1__loginResponse {

public:
    ns1__xfelSession *return_; /* SOAP 1.2 RPC return element (when namespace qualified) */ /* optional element of type ns1:xfelSession */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 20;
    } /* = unique id SOAP_TYPE_ns1__loginResponse */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__loginResponse() {
        ns1__loginResponse::soap_default(NULL);
    }

    virtual ~ns1__loginResponse() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__DecoderException
#define SOAP_TYPE_ns1__DecoderException (21)

/* ns1:DecoderException */
class SOAP_CMAC ns1__DecoderException {

public:
    std::string *message; /* optional element of type xsd:string */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 21;
    } /* = unique id SOAP_TYPE_ns1__DecoderException */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__DecoderException() {
        ns1__DecoderException::soap_default(NULL);
    }

    virtual ~ns1__DecoderException() {
    }
};
#endif

#ifndef SOAP_TYPE_ns1__UnsupportedEncodingException
#define SOAP_TYPE_ns1__UnsupportedEncodingException (22)

/* ns1:UnsupportedEncodingException */
class SOAP_CMAC ns1__UnsupportedEncodingException {

public:
    std::string *message; /* optional element of type xsd:string */
    struct soap *soap; /* transient */
public:

    virtual int soap_type() const {
        return 22;
    } /* = unique id SOAP_TYPE_ns1__UnsupportedEncodingException */
    virtual void soap_default(struct soap*);
    virtual void soap_serialize(struct soap*) const;
    virtual int soap_put(struct soap*, const char*, const char*) const;
    virtual int soap_out(struct soap*, const char*, int, const char*) const;
    virtual void *soap_get(struct soap*, const char*, const char*);
    virtual void *soap_in(struct soap*, const char*, const char*);

    ns1__UnsupportedEncodingException() {
        ns1__UnsupportedEncodingException::soap_default(NULL);
    }

    virtual ~ns1__UnsupportedEncodingException() {
    }
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (32)

/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail {

public:
    char *__any;
    ns1__DecoderException *ns1__DecoderException_; /* optional element of type ns1:DecoderException */
    ns1__UnsupportedEncodingException *ns1__UnsupportedEncodingException_; /* optional element of type ns1:UnsupportedEncodingException */
    int __type; /* any type of element <fault> (defined below) */
    void *fault; /* transient */
public:

    int soap_type() const {
        return 32;
    } /* = unique id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef SOAP_TYPE___ns1__login
#define SOAP_TYPE___ns1__login (40)

/* Operation wrapper: */
struct __ns1__login {

public:
    ns1__login *ns1__login_; /* optional element of type ns1:login */
public:

    int soap_type() const {
        return 40;
    } /* = unique id SOAP_TYPE___ns1__login */
};
#endif

#ifndef SOAP_TYPE___ns1__logout
#define SOAP_TYPE___ns1__logout (44)

/* Operation wrapper: */
struct __ns1__logout {

public:
    ns1__logout *ns1__logout_; /* optional element of type ns1:logout */
public:

    int soap_type() const {
        return 44;
    } /* = unique id SOAP_TYPE___ns1__logout */
};
#endif

#ifndef SOAP_TYPE___ns1__getUserNonce
#define SOAP_TYPE___ns1__getUserNonce (48)

/* Operation wrapper: */
struct __ns1__getUserNonce {

public:
    ns1__getUserNonce *ns1__getUserNonce_; /* optional element of type ns1:getUserNonce */
public:

    int soap_type() const {
        return 48;
    } /* = unique id SOAP_TYPE___ns1__getUserNonce */
};
#endif

#ifndef SOAP_TYPE___ns1__singleSignOn
#define SOAP_TYPE___ns1__singleSignOn (52)

/* Operation wrapper: */
struct __ns1__singleSignOn {

public:
    ns1__singleSignOn *ns1__singleSignOn_; /* optional element of type ns1:singleSignOn */
public:

    int soap_type() const {
        return 52;
    } /* = unique id SOAP_TYPE___ns1__singleSignOn */
};
#endif

#ifndef SOAP_TYPE___ns1__sessionsByIp
#define SOAP_TYPE___ns1__sessionsByIp (56)

/* Operation wrapper: */
struct __ns1__sessionsByIp {

public:
    ns1__sessionsByIp *ns1__sessionsByIp_; /* optional element of type ns1:sessionsByIp */
public:

    int soap_type() const {
        return 56;
    } /* = unique id SOAP_TYPE___ns1__sessionsByIp */
};
#endif

#ifndef SOAP_TYPE___ns1__hasActiveSession
#define SOAP_TYPE___ns1__hasActiveSession (60)

/* Operation wrapper: */
struct __ns1__hasActiveSession {

public:
    ns1__hasActiveSession *ns1__hasActiveSession_; /* optional element of type ns1:hasActiveSession */
public:

    int soap_type() const {
        return 60;
    } /* = unique id SOAP_TYPE___ns1__hasActiveSession */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (61)

/* SOAP Header: */
struct SOAP_ENV__Header {

public:

    int soap_type() const {
        return 61;
    } /* = unique id SOAP_TYPE_SOAP_ENV__Header */
    #ifdef WITH_NOEMPTYSTRUCT
private:
    char dummy; /* dummy member to enable compilation */
    #endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (62)

/* SOAP Fault Code: */
struct SOAP_ENV__Code {

public:
    char *SOAP_ENV__Value; /* optional element of type xsd:QName */
    struct SOAP_ENV__Code *SOAP_ENV__Subcode; /* optional element of type SOAP-ENV:Code */
public:

    int soap_type() const {
        return 62;
    } /* = unique id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (64)

/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason {

public:
    char *SOAP_ENV__Text; /* optional element of type xsd:string */
public:

    int soap_type() const {
        return 64;
    } /* = unique id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (65)

/* SOAP Fault: */
struct SOAP_ENV__Fault {

public:
    char *faultcode; /* optional element of type xsd:QName */
    char *faultstring; /* optional element of type xsd:string */
    char *faultactor; /* optional element of type xsd:string */
    struct SOAP_ENV__Detail *detail; /* optional element of type SOAP-ENV:Detail */
    struct SOAP_ENV__Code *SOAP_ENV__Code; /* optional element of type SOAP-ENV:Code */
    struct SOAP_ENV__Reason *SOAP_ENV__Reason; /* optional element of type SOAP-ENV:Reason */
    char *SOAP_ENV__Node; /* optional element of type xsd:string */
    char *SOAP_ENV__Role; /* optional element of type xsd:string */
    struct SOAP_ENV__Detail *SOAP_ENV__Detail; /* optional element of type SOAP-ENV:Detail */
public:

    int soap_type() const {
        return 65;
    } /* = unique id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
