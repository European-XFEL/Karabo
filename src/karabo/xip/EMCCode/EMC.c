/*
EMC reconstruction algorithm for unoriented diffraction data

Outputs an intensity model on a cubic grid given unoriented diffraction data as input.
Data should be in the sparse format generated by make_data.c.
The output intensity file, finish_intensity.dat, has -1 written in the beamstop region. 
EMC iterations begin with the intensities in start_intensity.dat; if this file is absent from the 
working directory, reconstruction begins with a random intensity pattern. 
Information about each EMC iteration is written to the file EMC.log.
Rotation group samples are specified by the input file quaternion.dat.

Written by V. Elser; last modified April 2009.

Reference: "A reconstruction algorithm for single-particle diffraction imaging experiments"
Duane Ne-Te Loh and Veit Elser, 2009.


compile:
gcc -O3 EMC.c -lm -o EMC

usage:
EMC iter (iter = number of iterations)

needs:
detector.dat, quaternion.dat, photons.dat, [start_intensity.dat]

makes:
finish_intensity.dat, EMC.log

*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#define EULER 0.57721566490153286
#define P_MIN .001

double rot[3][3] ;
double (*quat)[5] ;
double (*pix)[3] ;
int (*stop)[3] ;
int *ones, *multi, **place_ones, **place_multi, **count ;
double ***intens1, ***intens2, ***inter_weight, *s, *u, *p ;
float **w_in, **w_out ;
int q_max, size, num_pix, num_stop, num_rot, num_data ;
double mean_count, rescale, intens_norm ;

int setup() ;
void initialize() ;
double emc() ;
void expand() ;
double maximize() ;
void compress() ;
void sym_intens() ;
void print_intens() ;
void free_mem() ;
void make_rot( int ) ;


int main(int argc, char* argv[])
	{
	int iter, i ;
	double rms_change ;
	FILE *fp ;
	
	if ( argc == 2 )
		iter = atoi(argv[1]) ;
	else
		{
		printf("expected one argument: iter\n") ;
		return 0 ;
		}
		
	if (!setup())
		return 0 ;
		
	initialize() ;
	
	fp = fopen("EMC.log", "w") ;
	fprintf(fp, "num_rot = %d    num_data = %d    num_pix = %d    num_stop = %d\n", num_rot, num_data, num_pix, num_stop) ;
	fprintf(fp, "mean_count = %f    oriented_info_rate = %f\n\n", mean_count, (1.-EULER) * mean_count ) ;
	fclose(fp) ;
	
	for (i = 1 ; i <= iter ; ++i)
		{
		rms_change = emc() ;
		
		fp = fopen("EMC.log", "a") ;
		fprintf(fp, "iter = %d    rms_change = %f\n\n", i, rms_change) ;
		fclose(fp) ;
		
		print_intens() ;
		}
	
	free_mem() ;
	
	return 0 ;
	}
	
	
double emc()
	{
	double info, change = 0., d ;
	int x, y, z ;
	time_t t1, t2 ;
	FILE *fp ;
	
	time(&t1) ;
	
	expand() ;
	
	info = maximize() ;
	
	compress() ;
	
	sym_intens() ;
	
	time(&t2) ;
		
	fp = fopen("EMC.log", "a") ;
	fprintf(fp, "    info_rate_ratio = %f   iter_time = %.0f sec\n", 1. - info / ((1.-EULER) * mean_count), difftime(t2, t1)) ;
	fclose(fp) ;
	
	for (x = 0 ; x < size ; ++x)
	for (y = 0 ; y < size ; ++y)
	for (z = 0 ; z < size ; ++z)
		{
		d = intens1[x][y][z] - intens2[x][y][z] ;
		change += d*d ;
		intens1[x][y][z] = intens2[x][y][z] ;
		}
	
	return (num_pix / intens_norm) * sqrt( change / (size*size*size) ) ;
	}
	
	
double maximize()
	{
	int d, r, t ;
	double max_exp, p_sum ;
	double mutual_info = 0. ;
	double rot_intens, total_intens = 0. ;
	double weight ;
	double w ;
	int *place_ones_d, *place_multi_d, *count_d ;
	float *w_in_r, *w_out_r ;
	
	for (r = 0 ; r < num_rot ; ++r)
		{
		rot_intens = 0. ;
		for (t = 0 ; t < num_pix ; ++t)
			rot_intens += w_in[r][t] ;
			
		total_intens += quat[r][4] * rot_intens ;
		}
		
	rescale = mean_count / total_intens ;
	
	for (r = 0 ; r < num_rot ; ++r)
		{
		s[r] = 0. ;
		
		weight = quat[r][4] ;
		
		u[r] = log(weight) ;
		for (t = 0 ; t < num_pix ; ++t)
			{
			w = w_in[r][t] * rescale ;
			u[r] -= w ;
			w_in[r][t] = log(w) ;
			
			w_out[r][t] = 0. ;
			}
		}
	
	for (d = 0 ; d < num_data ; ++d)
		{
		place_ones_d = place_ones[d] ;
		place_multi_d = place_multi[d] ;
		count_d = count[d] ;
		
		max_exp = -100. * num_pix ;
		for (r = 0 ; r < num_rot ; ++r)
			{
			p[r] = u[r] ;
			
			w_in_r = w_in[r] ;
			
			for (t = 0 ; t < ones[d] ; ++t)
				p[r] += w_in_r[place_ones_d[t]] ;
				
			for (t = 0 ; t < multi[d] ; ++t)
				p[r] += count_d[t] * w_in_r[place_multi_d[t]] ;
				
			if (p[r] > max_exp)
				max_exp = p[r] ;
			}
		
		p_sum = 0. ;
		for (r = 0 ; r < num_rot ; ++r)
			{
			p[r] = exp(p[r] - max_exp) ;
			p_sum += p[r] ;
			}
			
		for (r = 0 ; r < num_rot ; ++r)
			{
			p[r] /= p_sum ;
			
			if (p[r] > 0.)
				mutual_info += p[r] * log(p[r] / quat[r][4]) ;
			
			if (p[r] < P_MIN)
				continue ;
				
			s[r] += p[r] ;
				
			w_out_r = w_out[r] ;
			
			for (t = 0 ; t < ones[d] ; ++t)
				w_out_r[place_ones_d[t]] += p[r] ;
				
			for (t = 0 ; t < multi[d] ; ++t)
				w_out_r[place_multi_d[t]] += p[r] * count_d[t] ;
			}
		}
	
	for (r = 0 ; r < num_rot ; ++r)
		{
		if (s[r] == 0.)
			continue ;
			
		for (t = 0 ; t < num_pix ; ++t)
			w_out[r][t] /= s[r] ;
		}
	
	return mutual_info / num_data ;
	}
	
	
void initialize()
	{
	int d, t, r ;
	double photon_count, total_count = 0. ;
	double total_weight = 0. ;
	
	for (d = 0 ; d < num_data ; ++d)
		{
		photon_count = ones[d] ;
		for (t = 0 ; t < multi[d] ; ++t)
			photon_count += count[d][t] ;
		
		total_count += photon_count ;
		}
		
	mean_count = total_count / num_data ;
	
	for (r = 0 ; r < num_rot ; ++r)
		total_weight += quat[r][4] ;
		
	for (r = 0 ; r < num_rot ; ++r)
		quat[r][4] /= total_weight ;
	}
	
	
void expand()
	{
	int r, t, i, j ;
	double rot_pix[3] ;
	int x, y, z ;
	double tx, ty, tz, fx, fy, fz, cx, cy, cz ;
	
	for (r = 0 ; r < num_rot ; ++r)
		{
		make_rot(r) ;
		
		for (t = 0 ; t < num_pix ; ++t)
			{
			for (i = 0 ; i < 3 ; ++i)
				{
				rot_pix[i] = 0. ;
				for (j = 0 ; j < 3 ; ++j)
					rot_pix[i] += rot[i][j]*pix[t][j] ;
				}
				
			tx = rot_pix[0] + q_max ;
			ty = rot_pix[1] + q_max ;
			tz = rot_pix[2] + q_max ;
			
			x = tx ;
			y = ty ;
			z = tz ;
			
			fx = tx - x ;
			fy = ty - y ;
			fz = tz - z ;
			
			cx = 1. - fx ;
			cy = 1. - fy ;
			cz = 1. - fz ;
			
			w_in[r][t] = cx*(cy*(cz*intens1[x][y][z] + fz*intens1[x][y][z+1]) + fy*(cz*intens1[x][y+1][z] + fz*intens1[x][y+1][z+1])) + fx*(cy*(cz*intens1[x+1][y][z] + fz*intens1[x+1][y][z+1]) + fy*(cz*intens1[x+1][y+1][z] + fz*intens1[x+1][y+1][z+1])) ;
			}
		}
	}
	
	
void compress()
	{
	int r, t, i, j ;
	double rot_pix[3] ;
	int x, y, z ;
	double tx, ty, tz, fx, fy, fz, cx, cy, cz ;
	double w, f ;
	double norm ;
		
	for (x = 0 ; x < size ; ++x)
	for (y = 0 ; y < size ; ++y)
	for (z = 0 ; z < size ; ++z)
		{
		inter_weight[x][y][z] = 0. ;
		intens2[x][y][z] = 0. ;
		}
	
	for (r = 0 ; r < num_rot ; ++r)
		{
		if (s[r] == 0.)
			continue ;
			
		make_rot(r) ;
		
		for (t = 0 ; t < num_pix ; ++t)
			{
			for (i = 0 ; i < 3 ; ++i)
				{
				rot_pix[i] = 0. ;
				for (j = 0 ; j < 3 ; ++j)
					rot_pix[i] += rot[i][j]*pix[t][j] ;
				}
				
			tx = rot_pix[0] + q_max ;
			ty = rot_pix[1] + q_max ;
			tz = rot_pix[2] + q_max ;
			
			x = tx ;
			y = ty ;
			z = tz ;
			
			fx = tx - x ;
			fy = ty - y ;
			fz = tz - z ;
			
			cx = 1. - fx ;
			cy = 1. - fy ;
			cz = 1. - fz ;
			
			w = w_out[r][t] ;
			
			f = cx*cy*cz ;
			inter_weight[x][y][z] += f ;
			intens2[x][y][z] += f * w ;
			
			f = cx*cy*fz ;
			inter_weight[x][y][z+1] += f ;
			intens2[x][y][z+1] += f * w ;
			
			f = cx*fy*cz ;
			inter_weight[x][y+1][z] += f ;
			intens2[x][y+1][z] += f * w ;
			
			f = cx*fy*fz ;
			inter_weight[x][y+1][z+1] += f ;
			intens2[x][y+1][z+1] += f * w ;
			
			f = fx*cy*cz ;
			inter_weight[x+1][y][z] += f ;
			intens2[x+1][y][z] += f * w ;
			
			f = fx*cy*fz ;
			inter_weight[x+1][y][z+1] += f ;
			intens2[x+1][y][z+1] += f * w ;
			
			f = fx*fy*cz ;
			inter_weight[x+1][y+1][z] += f ;
			intens2[x+1][y+1][z] += f * w ;
			
			f = fx*fy*fz ;
			inter_weight[x+1][y+1][z+1] += f ;
			intens2[x+1][y+1][z+1] += f * w ;
			}
		}
		
	norm = intens_norm / mean_count ;
	for (x = 0 ; x < size ; ++x)
	for (y = 0 ; y < size ; ++y)
	for (z = 0 ; z < size ; ++z)
		if (inter_weight[x][y][z] != 0.)
			intens2[x][y][z] *= norm / inter_weight[x][y][z] ;
	}
	
	
void sym_intens()
	{
	int x, y, z ;
	double ave_intens ;
	
	for (x = 0 ; x < size ; ++x)
	for (y = 0 ; y < size ; ++y)
	for (z = 0 ; z < q_max ; ++z)
		{
		ave_intens = .5 * (intens2[x][y][z] + intens2[size-x-1][size-y-1][size-z-1]) ;
		intens2[x][y][z] = ave_intens ;
		intens2[size-x-1][size-y-1][size-z-1] = ave_intens ;
		}
		
	for (x = 0 ; x < size ; ++x)
	for (y = 0 ; y < q_max ; ++y)
		{
		ave_intens = .5 * (intens2[x][y][q_max] + intens2[size-x-1][size-y-1][q_max]) ;
		intens2[x][y][q_max] = ave_intens ;
		intens2[size-x-1][size-y-1][q_max] = ave_intens ;
		}
		
	for (x = 0 ; x < q_max ; ++x)
		{
		ave_intens = .5 * (intens2[x][q_max][q_max] + intens2[size-x-1][q_max][q_max]) ;
		intens2[x][q_max][q_max] = ave_intens ;
		intens2[size-x-1][q_max][q_max] = ave_intens ;
		}
	}
	
	
void print_intens()
	{
	FILE *fp ;
	int x, y, z ;
	int t ;
	
	fp = fopen("finish_intensity.dat", "w") ;
	
	for (t = 0 ; t < num_stop ; ++t)
		intens2[stop[t][0]][stop[t][1]][stop[t][2]] = -1. ;
	
	for (x = 0 ; x < size ; ++x)
	for (y = 0 ; y < size ; ++y)
		{
		for (z = 0 ; z < size ; ++z)
			fprintf(fp, "%21.15e ", intens2[x][y][z]) ;
			
		fprintf(fp, "\n") ;
		}
		
	fclose(fp) ;
	}
	
	
int setup()
	{
	FILE *fp ;
	int i, j, k, d, r, t ;
	int rand_start = 0 ;
	
	fp = fopen("detector.dat", "r") ;
	if (!fp)
		{
		printf("cannot open detector.dat\n") ;
		return 0 ;
		}
		
	fscanf(fp, "%d %d %d", &q_max, &num_pix, &num_stop) ;
	
	size = 2*q_max + 1 ;
	
	pix = malloc(num_pix * sizeof(*pix)) ;
	
	for (t = 0 ; t < num_pix ; ++t)
	for (i = 0 ; i < 3 ; ++i)
		fscanf(fp, "%lf", &pix[t][i]) ;
		
	stop = malloc(num_stop * sizeof(*stop)) ;
	
	for (t = 0 ; t < num_stop ; ++t)
	for (i = 0 ; i < 3 ; ++i)
		{
		fscanf(fp, "%d", &stop[t][i]) ;
		stop[t][i] += q_max ;
		}
	
	fclose(fp) ;
	
	fp = fopen("start_intensity.dat", "r") ;
	if (!fp)
		{
		rand_start = 1 ;
		srand( time(0) ) ;
		}
	
	intens1 = malloc(size * sizeof(double**)) ;
	intens2 = malloc(size * sizeof(double**)) ;
	inter_weight = malloc(size * sizeof(double**)) ;
	for (i = 0 ; i < size ; ++i)
		{
		intens1[i] = malloc(size * sizeof(double*)) ;
		intens2[i] = malloc(size * sizeof(double*)) ;
		inter_weight[i] = malloc(size * sizeof(double*)) ;
		
		for (j = 0 ; j < size ; ++j)
			{
			intens1[i][j] = malloc(size * sizeof(double)) ;
			intens2[i][j] = malloc(size * sizeof(double)) ;
			inter_weight[i][j] = malloc(size * sizeof(double)) ;
			
			if (!rand_start)
				for (k = 0 ; k < size ; ++k)
					fscanf(fp, "%lf", &intens1[i][j][k]) ;
			else
				for (k = 0 ; k < size ; ++k)
					intens1[i][j][k] = ((double) rand()) / RAND_MAX ;
			}
		}
		
	if (!rand_start)
		{
		for (t = 0 ; t < num_stop ; ++t)
	 		intens1[stop[t][0]][stop[t][1]][stop[t][2]] = 0. ;
		
		fclose(fp) ;
		}
	
	fp = fopen("quaternion.dat", "r") ;
	if (!fp)
		{
		printf("cannot open quaternion.dat\n") ;
		return 0 ;
		}
		
	fscanf(fp, "%d", &num_rot) ;
	
	quat = malloc(num_rot * sizeof(*quat)) ;
	
	for (r = 0 ; r < num_rot ; ++r)
	for (i = 0 ; i < 5 ; ++i)
		fscanf(fp, "%lf", &quat[r][i]) ;
	
	fclose(fp) ;
	
	fp = fopen("photons.dat", "r") ;
	if (!fp)
		{
		printf("cannot open photons.dat\n") ;
		return 0 ;
		}
		
	fscanf(fp, "%d %lf", &num_data, &intens_norm) ;
	
	ones = malloc(num_data * sizeof(int*)) ;
	place_ones = malloc(num_data * sizeof(int**)) ;
	multi = malloc(num_data * sizeof(int*)) ;
	place_multi = malloc(num_data * sizeof(int**)) ;
	count = malloc(num_data * sizeof(int**)) ;
	
	for (d = 0 ; d < num_data ; ++d)
		{
		fscanf(fp, "%d", &ones[d]) ;
		
		place_ones[d] = malloc(ones[d] * sizeof(int*)) ;
		
		for (t = 0 ; t < ones[d] ; ++t)
			fscanf(fp, "%d", &place_ones[d][t]) ;
		
		
		fscanf(fp, "%d", &multi[d]) ;
		
		place_multi[d] = malloc(multi[d] * sizeof(int*)) ;
		count[d] = malloc(multi[d] * sizeof(int*)) ;
	
		for (t = 0 ; t < multi[d] ; ++t)
			fscanf(fp, "%d %d", &place_multi[d][t], &count[d][t]) ;
		}
	
	fclose(fp) ;
	
	w_in = malloc(num_rot * sizeof(double*)) ;
	w_out = malloc(num_rot * sizeof(double*)) ;
	s = malloc(num_rot * sizeof(double)) ;
	u = malloc(num_rot * sizeof(double)) ;
	p = malloc(num_rot * sizeof(double)) ;
	
	for (r = 0 ; r < num_rot ; ++r)
		{
		w_in[r] = malloc(num_pix * sizeof(double)) ;
		if (w_in[r] == NULL)
			{
			printf("insufficient memory\n") ;
			return 0 ;
			}
			
		w_out[r] = malloc(num_pix * sizeof(double)) ;
		if (w_out[r] == NULL)
			{
			printf("insufficient memory\n") ;
			return 0 ;
			}
		}
	
	return 1 ;
	}
	
	
void free_mem()
	{
	int i, j, d, r ;
	
	free(pix) ;
	free(stop) ;
	
	for (i = 0 ; i < size ; ++i)
		{
		for (j = 0 ; j < size ; ++j)
			{
			free(intens1[i][j]) ;
			free(intens2[i][j]) ;
			free(inter_weight[i][j]) ;
			}
			
		free(intens1[i]) ;
		free(intens2[i]) ;
		free(inter_weight[i]) ;
		}
	free(intens1) ;
	free(intens2) ;
	free(inter_weight) ;
	
	free(quat) ;
	
	for (d = 0 ; d < num_data ; ++d)
		{
		free(place_ones[d]) ;
		free(place_multi[d]) ;
		free(count[d]) ;
		}
		
	free(ones) ;
	free(multi) ;
	free(place_ones) ;
	free(place_multi) ;
	free(count) ;
	
	for (r = 0 ; r < num_rot ; ++r)
		{
		free(w_in[r]) ;
		free(w_out[r]) ;
		}
	free(w_in) ;
	free(w_out) ;
	
	free(s) ;
	free(u) ;
	free(p) ;
	}
	
	
void make_rot( int r )
	{
	double q0, q1, q2, q3, q01, q02, q03, q11, q12, q13, q22, q23, q33 ;
	
	q0 = quat[r][0] ;
	q1 = quat[r][1] ;
	q2 = quat[r][2] ;
	q3 = quat[r][3] ;
	
	q01 = q0*q1 ;
	q02 = q0*q2 ;
	q03 = q0*q3 ;
	q11 = q1*q1 ;
	q12 = q1*q2 ;
	q13 = q1*q3 ;
	q22 = q2*q2 ;
	q23 = q2*q3 ;
	q33 = q3*q3 ;
	
	rot[0][0] = 1. - 2.*(q22 + q33) ;
	rot[0][1] = 2.*(q12 + q03) ;
	rot[0][2] = 2.*(q13 - q02) ;
	rot[1][0] = 2.*(q12 - q03) ;
	rot[1][1] = 1. - 2.*(q11 + q33) ;
	rot[1][2] = 2.*(q01 + q23) ;
	rot[2][0] = 2.*(q02 + q13) ;
	rot[2][1] = 2.*(q23 - q01) ;
	rot[2][2] = 1. - 2.*(q11 + q22) ;
	}

