#!/bin/bash
#
# This script should be used in the karaboDeviceDevelopment environment.
# The purpose of this script is to ease device development for Karabo
# 


#original working directory
origCWD=`pwd`

# Make sure the script runs in this directory
scriptDir=$(dirname `[[ $0 = /* ]] && echo "$0" || echo "$PWD/${0#./}"`)
cd ${scriptDir}
if [ $? -ne 0 ]; then
    echo "ERROR Could not change directory to ${scriptDir}"
    exit 1;
fi

# Read the Karabo version
if [ -f "VERSION" ]; then
    VERSION=$(cat VERSION)
else
    VERSION=$(git rev-parse --short HEAD)
fi
#set temporary for testing
#VERSION=1.2.3
    
VERSION_MAJ=${VERSION%.*.*}
VERSION_MIN=${VERSION%.*}

#echo "Found version: $VERSION"

function getEmail() {
    
    if [ -f "${HOME}/.karabo/email" ];then
        email=`cat ${HOME}/.karabo/email`
    else
        echo
        echo -n "Please type your email address: "
        read email
        echo "Your email address will be stored in ${HOME}/.karabo/email"
        echo -n "Is this correct? $email [y/n] "
        read c
        if [ "x$c" == "xy" ]; then 
            if [ ! -d "${HOME}/.karabo" ]; then
                mkdir ${HOME}/.karabo
            fi
            echo $email > ${HOME}/.karabo/email
        else
            echo "Nothing done"
            exit 1;
        fi
    fi
}

function getKaraboFramework() {
    if [ -z $KARABO ]; then
	echo "\$KARABO is not defined. Make sure you have sourced the activate script for the Karabo Framework which you would like to use."
	exit 1
    fi
}

function getSvnPath() {
    if [ -z $KARABOPACKAGESSVNPATH ]; then
        if [ -e $HOME/.karabo/karaboPackagesSvnPath ]; then
            KARABOPACKAGESSVNPATH=$(cat $HOME/.karabo/karaboPackagesSvnPath)
        else
          echo "WARNING Could not find $HOME/.karabo/karaboPackagesSvnPath. Setting default one."
          KARABOPACKAGESSVNPATH=https://svnsrv.desy.de/desy/EuXFEL/karaboPackages
          echo $KARABOPACKAGESSVNPATH 
          echo $KARABOPACKAGESSVNPATH > ${HOME}/.karabo/karaboPackagesSvnPath
#          exit 1
        fi
    fi
    svnPath=$KARABOPACKAGESSVNPATH

    if [ -z $KARABODEPSSVNPATH ]; then
        if [ -e $HOME/.karabo/karaboDepsSvnPath ]; then
            KARABODEPSSVNPATH=$(cat $HOME/.karabo/karaboDepsSvnPath)
        else
          echo "WARNING Could not find $HOME/.karabo/karaboDepsSvnPath. Setting default one."
          KARABODEPSSVNPATH=https://svnsrv.desy.de/desy/EuXFEL/karaboPackages
          echo $KARABODEPSSVNPATH 
          echo $KARABODEPSSVNPATH > ${HOME}/.karabo/karaboDepsSvnPath
#          exit 1
        fi
    fi
    svnDepsPath=$KARABODEPSSVNPATH
}


function setSvnPath() {
    defaultSvn=https://svnsrv.desy.de/desy/EuXFEL/karaboPackages
    isCorrect=0
    read -e -p "Please enter the path to Karabo Packages SVN repository [$defaultSvn]: " user
    if [ -z "$user" ]; then
        user=$defaultSvn
    fi
    svn ls $user 2>/dev/null >/dev/null
    if [ $? -eq 0 ];then
      isCorrect=1
    fi
    if [[ "$isCorrect" == "0" ]]; then
        echo
        echo " SVN path \"$user\" could not be found or you don't have appropiate credentials."
        echo
        exit 1
    fi
    echo
    echo "The path to Karabo Packages SVN repository is stored in ${HOME}/.karabo/karaboPackagesSvnPath"
    echo
    echo $user > ${HOME}/.karabo/karaboPackagesSvnPath

    #defaultDepsSvn=https://svnsrv.desy.de/desy/EuXFEL/WP76/karabo/karaboPackages
    defaultDepsSvn=https://svnsrv.desy.de/desy/EuXFEL/karaboPackages
    isCorrect=0
    read -e -p "Please enter the path to Karabo Dependencies SVN repository [$defaultDepsSvn]: " user
    if [ -z "$user" ]; then
        user=$defaultDepsSvn
    fi
    svn ls $user 2>/dev/null >/dev/null
    if [ $? -eq 0 ];then
      isCorrect=1
    fi
    if [[ "$isCorrect" == "0" ]]; then
        echo
        echo " SVN path \"$user\" could not be found or you don't have appropiate credentials."
        echo
        exit 1
    fi
    echo
    echo "The path to Karabo Dependencies SVN repository is stored in ${HOME}/.karabo/karaboDepsSvnPath"
    echo
    echo $user > ${HOME}/.karabo/karaboDepsSvnPath
}


toUpper() {
    local char="$*"
    out=$(echo $char | tr [:lower:] [:upper:])
    local retval=$?
    echo "$out"
    unset out char
    return $retval
}


toLower() {
    local char="$*"
    out=$(echo $char | tr [:upper:] [:lower:])
    local retval=$?
    echo "$out"
    unset out
    unset char
    return $retval
}

convertsecs() {
 ((d=${1}/(3600*24)))
 #((h=${1}/3600))
 ((h=(${1}%(3600*24))/3600))
 ((m=(${1}%3600)/60))
 ((s=${1}%60))
 printf "%02d day(s) %02d hour(s) %02d minute(s) %02d second(s)\n" $d $h $m $s
}

# Argument is a path to a directory. If it does not exist, it will be tried to
# created it, including its full path depth, i.e. using mkdir -p.
# If that creation fails, return 1, else 0. 
function takeCareDirExists()
{
    targetDir=$1
    if ! mkdir -p $targetDir ; then  # create if not yet there
        echo "ERROR: Cannot create directory '$targetDir': Is there a file?" >&2
        return 1
    else
        return 0
    fi
}

# Etc directory (global variable)
etcDir="$scriptDir/etc"

# Global indication whether there was an error
hasError="n"

#number of cores
OS=$(uname -s)
if [ "$OS" = "Linux" ]; then
    numCores=`grep "processor" /proc/cpuinfo | wc -l`
elif [ "$OS" = "Darwin" ]; then
    numCores=`sysctl hw.ncpu | awk '{print $2}'`
fi
# Cut the total number to ensure memory fitness
if [ "$numCores" -gt "8" ]; then numCores=8; fi
#number of make threads (used like that: make -j${numMakeThreads} )
numMakeThreads=$numCores;
# fallback, if number of cores not recognized properly use at least one
if [ "$numCores" -eq "0" ]; then
  numCores=1
  numMakeThreads=1
fi
MACHINE=$(uname -m)
if [ "$OS" = "Linux" ]; then
    DISTRO_ID=( $(lsb_release -is) )
    DISTRO_RELEASE=$(lsb_release -rs)
    if [ "$DISTRO_ID" = "Scientific" -o "$DISTRO_ID" = "CentOS" ]; then
       DISTRO_RELEASE=${DISTRO_RELEASE%%\.*}
    fi
fi


oldSvnPath=""

# Level 0
new=0
checkout=0
import=0
install_s=0
uninstall=0
list=0
update=0
rebuild=0
#forget=0  # handles removeContinueBuildInfo
createBranch=0
createTag=0
setSvn=0
updateProjectFiles=0

# Level 1
packageCategory=""
packageName=""
moduleName=""
configurationName=""
packageDevPath=$scriptDir
listWhat=""
isSvn=1
force=0
buildType="Debug"
#svnUpdateConflict="postpone"
forceRebuild="canSkip"
forceInstallation=0
checkLocal="n"  #for update
clean="n"       #for update
templateName=""      #for new
#category=""     #for checkout
tag=""          #for checkout
revision="HEAD"     # for checkout
tagBranchFromRev="" # revision for tag/branch
svnTagName=""
svnBranchName=""
svnBranchFrom="trunk" # for branching
allList=0
verboseList=0

# Checks if selected package name and category are valid
# @param packageName The package name
# @param packageCategory The packages category
# 
# The function will exit the whole script upon failed validation
function validateNewPackage() {

    lowerPackageName=`echo $1 | tr  [:upper:]  [:lower:] | sed -e s#/##g`
    lowerPackageCategory=`echo $2 | tr  [:upper:]  [:lower:] | sed -e s#/##g`
    
    isValidPackageName=1
    isValidPackageCategory=0

    echo " Validating package and category names ..."
    refreshAllPackagesFromSvn now
    
    # Retrieve available packages
    while read type category package
    do
        if [[ ${type:0:1} = "#" || -z $category  ]]; then
            continue
        fi
        lowerCategory=`echo ${category} | tr  [:upper:]  [:lower:] | sed -e s#/##g`
        
        if [[ "$lowerCategory" = "$lowerPackageCategory" ]]; then
            isValidPackageCategory=1;
        fi
        lowerPackage=`echo ${package} | tr  [:upper:]  [:lower:] | sed -e s#/##g`
        if [[ "$lowerPackage" = "$lowerPackageName" ]]; then
            isValidPackageName=0;
        fi
    done < $etcDir/configurations/.all
    if [[ "$isValidPackageName" == "0" ]]; then
        echo " Package name \"$1\" does aleady exist. Please select another name."
        exit 1;
    fi
    if [[ "$isValidPackageCategory" == "0" ]]; then
        echo " Invalid package category: $2"
        exit 1;
    fi
}

function updateProject() {

    packageDevPath=$1
    packageName=$2
    packageCategory=$3

    packagePath=$packageDevPath/packages/$packageCategory/$packageName
    if [ ! -d $packagePath ]; then
            echo
            echo " Package $3 does not exists, check it out first"
            echo
            exit 1
    fi
    mkdir -p ${packagePath}_tmp
    cp -rf $etcDir/templates/cppDevice/minimal/nbproject/*.xml ${packagePath}_tmp
    cp -rf $etcDir/templates/cppDevice/minimal/nbproject/Karabo*.mk ${packagePath}_tmp
    cp -rf $etcDir/templates/cppDevice/minimal/src/tests/*.cc ${packagePath}_tmp
    
    # need to code better in case of multiple hh files, now assuming only one 
    className=`basename $packagePath/src/*hh .hh`
    emailAuthor=`grep 'Author: ' $packagePath/src/*.hh |awk -F'[<>]' '{print $2}'`
    templateName="minimal"
    currentDate=$(date +"%B, %Y, %I:%M %p")
    upperClassName=$(toUpper $className)
    filesToReplace=$(find ${packagePath}_tmp -type f -name '*.*')
    for file in $filesToReplace
    do
        if [ ! -d ${file} ]; then
           if [ "$OS" = "Darwin" ]; then
             sed -i "" -e s#__DATE__#"${currentDate}"#g \
             -e s#__EMAIL__#"${emailAuthor}"#g \
             -e s#__PACKAGE_NAME__#"${packageName}"#g \
             -e s#${templateName}#"${packageName}"#g \
             -e s#__CLASS_NAME__#"${className}"#g \
             -e s#__CLASS_NAME_ALL_CAPS__#"${upperClassName}"#g ${file}
            elif [ "$OS" = "Linux" ]; then
             sed -i -e s#__DATE__#"${currentDate}"#g \
             -e s#__EMAIL__#"${emailAuthor}"#g \
             -e s#__PACKAGE_NAME__#"${packageName}"#g \
             -e s#${templateName}#"${packageName}"#g \
             -e s#__CLASS_NAME__#"${className}"#g \
             -e s#__CLASS_NAME_ALL_CAPS__#"${upperClassName}"#g ${file}
            fi
        fi
        filename=${file##*/}
        base=${filename%.*}
        ext=${filename##*.}
        if [ "$base" = "__CLASS_NAME___App" ]; then
            mv $file ${packagePath}_tmp/${className}_App.$ext
        fi
        if [ "$base" = "__CLASS_NAME___Test" ]; then
            mv $file ${packagePath}_tmp/${className}_Test.$ext
        fi
    done
    cp -f ${packagePath}_tmp/*.xml ${packagePath}/nbproject/ 
    cp -f ${packagePath}_tmp/Karabo*.mk ${packagePath}/nbproject/ 
    if [ ! -d ${packagePath}/src/tests ]; then
        mkdir ${packagePath}/src/tests
        cp -f ${packagePath}_tmp/*.cc ${packagePath}/src/tests/
    fi
    rm -rf ${packagePath}_tmp


}



# This function configures the default template 
# @param $1 packagePath    Full path to the current package
# @param $2 packageName    Package name
# @param $3 className      Class name
# @param $4 templateName   Template name (fsmDevice, device, ...)
function configureTemplate() {

    #echo " configureTemplate()"
    packageName=$2
    cdate=$(date +"%B, %Y, %I:%M %p")
    className=$3 
    upperClassName=$(toUpper $className)
    templateName=$4
    
    directoriesToRename=$(find $1 -type d)
    for d in $directoriesToRename
    do
        newname=`echo $d | sed s#__PACKAGE_NAME__#"${packageName}"#g`
        if [[ "$d" != "$newname" && -e "$d" ]]; then
            mv $d $newname
        fi
    done

    filesToReplace=$(find $1 -type f -name '*.*')
    for file in $filesToReplace
    do
        if [ ! -d ${file} ]; then
           if [ "$OS" = "Darwin" ]; then
             sed -i "" -e s#__DATE__#"${cdate}"#g \
             -e s#__EMAIL__#"${email}"#g \
             -e s#__PACKAGE_NAME__#"${packageName}"#g \
             -e s#${templateName}#"${packageName}"#g \
             -e s#__CLASS_NAME__#"${className}"#g \
             -e s#__CLASS_NAME_ALL_CAPS__#"${upperClassName}"#g ${file}
            elif [ "$OS" = "Linux" ]; then
             sed -i -e s#__DATE__#"${cdate}"#g \
             -e s#__EMAIL__#"${email}"#g \
             -e s#__PACKAGE_NAME__#"${packageName}"#g \
             -e s#${templateName}#"${packageName}"#g \
             -e s#__CLASS_NAME__#"${className}"#g \
             -e s#__CLASS_NAME_ALL_CAPS__#"${upperClassName}"#g ${file}
            fi
	        #mv ${file}.new ${file}
        fi

        newname=`echo $file | sed s#__CLASS_NAME__#"${className}"#g`
        if [ "$file" != "$newname" ]; then
            mv $file $newname
        fi
    
    done
}

# checkout package
# checks DEPENDS file and checkout all dependencies
# If a package misses DEPENDS file, or files is empty, then no dependencies are taken into account
# @param $1 packageDevPath   The package development system path
# @param $2 packageName      The package name
# @param $3 categoryName     The category name
# @param $4 tag              SVN tag. The examples are: trunk, branches/0.1.0 tags/0.1.0 tags/0.1.2
# @param $5 force            0: no overwriting 1: force overwriting
# @param $6 isSvn            0: no integration 1: integration to repository
# @param $7 revision         SVN revision number
function checkoutPackage() {
    
    local packageDevPath=$1
    local package=$2
    local category=$3
    local tag=$4
    local force=$5
    local isSvn=$6
    local revision=$7

    local skip=0

    local isFound=0

    # in case of dependencies, change svnPath temporarily to old location of dependencies    
    oldSvnPath=$svnPath; if [[ "$category" == "dependencies" ]]; then svnPath=$svnDepsPath; fi

    svn ls $svnPath/$category/$package/$tag 2>/dev/null >/dev/null
    if [ $? -eq 0 ];then
      isFound=1
    fi
    if [[ "$isFound" == "0" ]]; then
        echo
        echo " Package \"$svnPath/$category/$package/$tag\" could not be found."
	echo " Check if the package name, category or version is properly specified"
	echo
        exit 1
    fi
    echo 
    echo -n " Checking out package \"$package\" ($category), please wait..."
    local packagePath=$packageDevPath/packages/$category/$package
    if [ ! -d $packageDevPath/packages ]; then
        mkdir -p $packageDevPath/packages
    fi
    if [ ! -d $packageDevPath/packages/$category ]; then
        mkdir -p $packageDevPath/packages/$category
    fi

    # If forced, everything that existed is wiped away
    if [[ "$force" == "1" ]]; then
	rm -rf $packagePath
    fi

    if [ -d $packagePath ]; then
	
	# Check, wether the tags are still the same
	cd $packagePath
	tagLocal=`svn info|grep "URL"`
	tagLocal=`expr "$tagLocal" : '.*/\(.*/.*\)'`
	dPart=${tagLocal%%/*}
	vPart=${tagLocal##*/}
	if [ "$vPart" == "trunk" ]; then
	    tagLocal=trunk
	fi
	cd $scriptDir
	if [[ "$tag" != "$tagLocal" ]]; then
	    echo
	    echo " WARNING Package \"$package\" already exists and is in wrong version."
	    echo "         Installation requires package $package in version $tag"
	    echo "         but it (locally) exists in version $tagLocal"
	    echo
	    echo -n " Do you want to change version (old package will be deleted)? [y/n] "
	    read c
	    if [ "x$c" == "xy" ]; then 
		rm -rf $packagePath
		if [[ "$isSvn" == "1" ]]; then
		    svn co -r $revision $svnPath/$category/$package/$tag $packagePath -q
		else
		    svn export -r $revision $svnPath/$category/$package/$tag $packagePath
		fi
		echo " Package now is in local version $tag."
	    else
		echo " Nothing done."
		return		
	    fi
	else
	    echo
	    echo " WARNING Package \"$package\" already exists."
	    echo
	    echo -n " Do you want to (svn) update the existing package? [y/n] "
	    read c
	    if [ "x$c" == "xy" ]; then 
		status=`((svn update --non-interactive --accept postpone $packagePath 2>&1 3>&-; echo \$? >&3 ) | \
                          tee -a $etcDir/update.log 1>&2 1>updateStatus.tmp  3>&- ) 3>&1` 
		rm updateStatus.tmp
            
		if [ $status -ne 0 ]; then
                    echo " ERROR svn update encountered some problems in $packagePath."
                    exit 1
		fi
		hasConflicts=$(svn status $packagePath | grep "C       ")
		if [ "$hasConflicts" != "" ]; then
	            echo " The following svn conflicts have been found:"
	            echo $hasConflicts
	            exit 1
		fi	    		
	    else
		echo " Nothing done."
		return
	    fi
	fi	
    else
	if [[ "$isSvn" == "1" ]]; then
	    svn co -r $revision $svnPath/$category/$package/$tag $packagePath -q
	    echo " done."
            echo " Package was checked out to $packageDevPath/packages/$category/$package"
	else
	    svn export -r $revision $svnPath/$category/$package/$tag $packagePath
	    echo " done."
            echo " Package was exported to $packageDevPath/packages/$category/$package"
	fi
    fi  

    # restoring previous svnPath
    svnPath=$oldSvnPath

    echo " Checking dependencies for package $package ... please wait"
    local deps=( `getArrayOfPackageDependencies $packagePath` )
    local depsNumberOfElements=${#deps[@]}
    if [ $depsNumberOfElements -gt 0 ]; then
       echo
       echo " Adding dependencies for package $package ... " 
       echo
    else
       echo
       echo " No dependencies defined for package $package"
       echo
    fi
    local idx=0
    while [ $idx -lt $depsNumberOfElements ]; do
        skip=0
        let "typeIdx = $idx"
        let "categoryIdx = $idx + 1"
        let "packageIdx = $idx + 2"
        let "tagIdx = $idx + 3"
        local packageDep=${deps[$packageIdx]}
        local categoryDep=${deps[$categoryIdx]}
        local tagDep=${deps[$tagIdx]}
        echo -n " Adding package $packageDep, please wait..."
        local packageDepPath=$packageDevPath/packages/$categoryDep/$packageDep
        if [ -d $packageDepPath ]; then
            if [[ "$force" == "0" ]]; then
                cd $packageDepPath
                tagDeplocal=`svn info|grep URL|awk -F/ '{print $NF}'`
                cd $scriptDir
                if [[ "$tagDep" != "$tagDeplocal" ]]; then
                   echo
                   echo "  Warning:"
                   echo "  You want to check out package $packageDep version $tagDep"
                   echo "  as a dependency of package $package version $tag"
                   echo "  but it exists already with version $tagDeplocal"
                   echo "  Checkout is skipped, resolve manually"
                   echo
                else
                   echo
                   echo "  Package $packageDep already exists, skipping "
                   echo
                fi
                skip=1
                #exit 1
            fi
        fi
        if [[ "$isSvn" == "1" && "$skip" == "0" ]]; then
             # TODO Check if svn rep is accessible
             # in case of dependencies, change svnPath temporarily to old location of dependencies    
            oldSvnPath=$svnPath; if [[ "$categoryDep" == "dependencies" ]]; then svnPath=$svnDepsPath; fi

            svn co -r $revision $svnPath/$categoryDep/$packageDep/$tagDep $packageDepPath -q
            echo " done."
            echo " Package was checked out to $packageDevPath/packages/$categoryDep/$packageDep"
        elif [[ "$isSvn" == "0" && "$skip" == "0" ]]; then
            svn export -r $revision $svnPath/$categoryDep/$packageDep/$tagDep $packageDepPath
            echo " done."
            echo " Package was exported to $packageDevPath/packages/$categoryDep/$packageDep"
        fi
        # you may call this function recursively to check also DEPENDS file of dependencies of current package
        # instead of one level checking and checkout done above
        # checkoutPackage $packageDevPath $packageName $category $tag $force $isSvn $revision

        # restoring previous svnPath
        svnPath=$oldSvnPath

        let "idx = $idx + 4"
    done 

}


# read DEPENDS and return array of package dependencies
# @param $1 package path
function getArrayOfPackageDependencies() {

    local allPackages
    local packageDependencies

    if [ ! -f $etcDir/configurations/.all ]; then
       refreshAllPackagesFromSvn now supress
    fi

    allPackages=(`cat $etcDir/configurations/.all | grep -v "^#" | grep -v "^$"`)
    allPackagesNumberOfElements=${#allPackages[@]}

    packageDependencies=(`cat $1/DEPENDS 2>/dev/null | grep -v "^#" | grep -v "^$" | awk '{print $3, $4}'`)
    packageDependenciesNumberOfElements=${#packageDependencies[@]}
    

    local dependencies=()
    local j=0
    while [ "$j" -lt "$packageDependenciesNumberOfElements" ]
    do

      let "packageJ = $j"
      let "tagJ = $j + 1"
      package=${packageDependencies[$packageJ]}
      tag=${packageDependencies[$tagJ]}

      local idx=0
      while [ "$idx" -lt "$allPackagesNumberOfElements" ]
      do
        let "typeIdx = $idx"
        let "categoryIdx = $idx + 1"
        let "packageIdx = $idx + 2"
        if [ "$package" = "${allPackages[$packageIdx]}" ]; then
           type=${allPackages[$typeIdx]}
           category=${allPackages[$categoryIdx]}
           #echo "install package $package with type $type in category $category. Tag: $tag" 
           dependencies=( "${dependencies[@]}" $type $category $package $tag )
           break
        fi
        let "idx = $idx + 3"
      done

      let "j = $j + 2"

    done
    # return the array of packages according to DEPENDS content  
    # in proper build order
    # This array has one dimension, but logically should be seen as 2 dimensional.
    # Content of the array:
    # [0] = typeOfFirstPackage [1] = categoryNameOfFirstPackage, [2] = packageNameOfFirstPackage, [3] = tagNameOfFirstPackage, [4] =
    # typeOfSecondPackage, [5] = categoryNameOfSecondPackage, [6] = packageNameOfSecondPackage, [7] = tagNameOfSecondPackage, ...
    echo "${dependencies[@]}"  

}



# Sets up a new package to host system
# @param $1 packageDevPath   The package development system path
# @param $2 packageCategory  The category name
# @param $3 packageName      The package name
# @param $4 templateType     The type of template (cpp-netbeans, device-netbeans)
# @param $5 templateName     Initial class definition templateName (for device-netbeans: device,fsmDevice)
# @param $6 className        The class name
# @param $7 force            0: no overwriting 1: force overwriting
# @param $8 isSvn            0: no integration 1: integration to repository
function setupNewPackage() {
    packageDevPath=$1
    packageCategory=$2
    packageName=$3
    templateType=$4
    templateName=$5
    className=$6
    force=$7 
    isSvn=$8

    packagePath=$packageDevPath/packages/$packageCategory/$packageName
    
    if [ -d $packagePath ]; then
        if [[ "$force" == "0" ]]; then
            echo
            echo " Package $3 already exists. (Use -f to overwrite)"
            echo
            exit 1
        fi
    fi

    if [ ! -d $etcDir/templates/$templateType ]; then
      echo
      echo " Template type $templateType is not supported"
      echo " Use 'list templates' to see available options"
      echo
      exit 1
    fi

    if [ ! -d $etcDir/templates/$templateType/$templateName ]; then
      echo
      echo " Template name $templateName is not supported"
      echo " Use 'list templates' to see available options"
      echo
      exit 1
    fi
    
    echo 
    echo -n " Creating new package \"$3\", please wait..."

    mkdir -p $packagePath
    if [[ "$isSvn" == "1" ]]; then

        # TODO Check if svn rep is accessible
        mkdir $packagePath/trunk
        mkdir $packagePath/branches
        # mkdir $packagePath/tags
        cp -rf $etcDir/templates/$templateType/$templateName/* $packagePath/trunk
        cp -rf $etcDir/templates/$templateType/$templateName/.[^.]* $packagePath/trunk 2>/dev/null
       
        # Clear all .svn folders and potential makefiles
        rm -rf `find $packagePath -name ".svn" -or -name 'Makefile-*' -or -name 'Package-*' -or -name "private"`
        
        # Configure the template
        configureTemplate $packagePath/trunk $packageName $className $templateName

        echo -n "(registering to svn)..."

        # in case of dependencies, change svnPath temporarily to old location of dependencies
        oldSvnPath=$svnPath; if [[ "$packageCategory" == "dependencies" ]]; then svnPath=$svnDepsPath; fi


        svn -q import $packagePath $svnPath/$packageCategory/$packageName -m "Auto-initial import of new package: $packageName ($packageCategory)"
        rm -rf $packagePath
        svn -q co $svnPath/$packageCategory/$packageName/trunk $packagePath
        svn -q propset -R svn:keywords "Id" $packagePath/src
        svn -q commit $packagePath -m "Auto-set svn properties of new package: $packageName ($packageCategory)"
        echo "done"

        # restoring previous svnPath
        svnPath=$oldSvnPath

        refreshAllPackagesFromSvn now 
        
    else
        cp -rf $etcDir/templates/$templateType/$templateName/* $packagePath
        cp -rf $etcDir/templates/$templateType/$templateName/.[^.]* $packagePath 2>/dev/null
        
        # Clear all .svn folders
        rm -rf `find $packagePath -name ".svn" -or -name 'Makefile-*' -or -name 'Package-*' -or -name "private"`
        #find $packagePath -name ".svn" -type d -exec rm -rf {} \; 2>/dev/null
        # Configure the template
        configureTemplate $packagePath $packageName $className $templateName
        echo "done"
    fi
        
    echo -e " New package \"$3\" was added to $packagePath\n"
}

# imports to svn a new package which was created with noSvn option
# only rough cleaning is done before import - take care of it yourself
# @param $1 The package development system path
# @param $2 The package name
# @param $3 The category name
function importPackage() {

    packageDevPath=$1
    packageName=$2
    packageCategory=$3

    packagePath=$packageDevPath/packages/$packageCategory/$packageName
    if [ ! -d $packagePath ]; then
        echo
        echo " Package $3 does not exists under"
        echo " "$packagePath
        echo " Check path to your unversioned package"
        exit 1
    fi

    validateNewPackage $packageName $packageCategory

    tempPackagePath=${packagePath}_import
    mkdir -p $tempPackagePath
    mkdir $tempPackagePath/trunk
    mkdir $tempPackagePath/branches
    # mkdir $tempPackagePath/tags

    # Clear all .svn folders and potential makefiles
    rm -rf `find $packagePath -name ".svn" -or -name 'Makefile-*' -or -name 'Package-*' -or -name "private" -or -name "*~"`
    rm -rf `find $packagePath -type l`
    rm -rf $packagePath/dist
    rm -rf $packagePath/build
    rm -rf $packagePath/.dep.inc
    #  For custom build from package.tar.gz you may need to delete directory created after untar'ing the package archive - not possible to implement

    cp -rf $packagePath/* $tempPackagePath/trunk 
    cp -rf $packagePath/.[^.]* $tempPackagePath/trunk 2>/dev/null

    # in case of dependencies, change svnPath temporarily to old location of dependencies
    oldSvnPath=$svnPath; if [[ "$packageCategory" == "dependencies" ]]; then svnPath=$svnDepsPath; fi

    svn -q import $tempPackagePath $svnPath/$packageCategory/$packageName -m "Auto-initial import of new package: $packageName ($packageCategory)"
    if [ $? -eq 0 ]; then
        echo
        echo " Succesfully imported $packageName"
        echo
        rm -rf $packagePath 
        svn -q co $svnPath/$packageCategory/$packageName/trunk $packagePath
        if [ $? -eq 0 ]; then
            rm -rf $tempPackagePath
        else
            echo "checkout error, leaving $tempPackagePath untouched"
        fi
    else
        echo 
        echo " Error importing $packageName"
        echo
        exit 1
    fi
    # restoring previous svnPath
    svnPath=$oldSvnPath
}




# Installs a selected package configuration to the suite
# For each package resolves its dependencies separately (one level only)
# @param $1 configuration The (file-)name of the configuration
# @param $2 buildType Either "Debug" or "Release"
# @param $3 force (1 0)
function installConfiguration() {
    
    configurationName=$1
    buildType=$2
    force=$3
    
    echo
    echo " Installing configuration \"$1\"..."
    
    # Parse the configuration file
    sortedPackages=( `getSortedArrayOfPackagesToInstall $1 ` )
    sortedPackagesNumberOfElements=${#sortedPackages[@]}

    local idx=-4
    local max_idx
    let "max_idx = $sortedPackagesNumberOfElements - 4"
    local rowIdx=-1
    while [ "$idx" -lt "$max_idx" ]
    do
	# These two lines are at the beginning of the loop because of the continue statements
	let "idx = $idx + 4"        
	let "rowIdx = $rowIdx + 1"   # see initialization (-3 and -1)
	
	let "typeIdx = $idx"
	let "categoryIdx = $idx + 1"
	let "packageIdx = $idx + 2"
	let "tagIdx = $idx + 3"
	
	local type=${sortedPackages[$typeIdx]}
	local category=${sortedPackages[$categoryIdx]}
	local package=${sortedPackages[$packageIdx]}
	local tag=${sortedPackages[$tagIdx]}
	
        if [[ ${type:0:1} == "#" || -z $category ]]; then
            continue
        fi        

	checkoutPackage $scriptDir $package $category $tag $force 1 $revision	
	buildPackage $package $category $buildType force
	    
    done
    
    echo
    echo " No more packages to install"
    echo
}

# Return the array of packages to be installed sorted according to svn directory listing
# @param $1 configuration to be installed
function getSortedArrayOfPackagesToInstall() {

    local allPackages
    local packagesToInstall

    if [ ! -f $etcDir/configurations/.all ]; then
       refreshAllPackagesFromSvn now supress
    fi

    allPackages=(`cat $etcDir/configurations/.all | grep -v "^#" | grep -v "^$"`)
    allPackagesNumberOfElements=${#allPackages[@]}
    packagesToInstall=(`cat $etcDir/configurations/$1 | grep -v "^#" | grep -v "^$" | awk '{print $3, $4}' | sort | uniq `)
    packagesToInstallNumberOfElements=${#packagesToInstall[@]}
    local sortedPackages
    sortedPackages=()

    local rowIdx=0
    local idx=0
    while [ "$idx" -lt "$allPackagesNumberOfElements" ]
    do
      let "typeIdx = $idx"  
      let "categoryIdx = $idx + 1"
      let "packageIdx = $idx + 2"
      #let "tagIdx = $idx + 3"

      #echo [$rowIdx]:   ${allPackages[$categoryIdx]} ${allPackages[$packageIdx]}
      local type=${allPackages[$typeIdx]}
      local category=${allPackages[$categoryIdx]}
      local package=${allPackages[$packageIdx]}
      #tag=${allPackages[$tagIdx]}

      local j=0
      while [ "$j" -lt "$packagesToInstallNumberOfElements" ]
      do
        #echo [$j]:  ${packagesToInstall[$j]}
        if [ "$package" = "${packagesToInstall[$j]}" ]; then
           let "tagIdx = $j + 1"
           local tag=${packagesToInstall[$tagIdx]}
           #echo "install package $package with type $type in category $category. Tag: $tag" 
           sortedPackages=( "${sortedPackages[@]}" $type $category $package $tag )
           break
        fi
        let "j = $j + 2"
      done


      let "idx = $idx + 3"
      let "rowIdx = $rowIdx + 1"

    done
    # return the array of packages to be installed sorted according to svn directory listing
    # and with removed duplicates
    # This array has one dimension, but logically should be seen as 2 dimensional.
    # Content of the array:
    # [0] = typeOfFirstPackage [1] = categoryNameOfFirstPackage, [2] = packageNameOfFirstPackage, [3] = tagNameOfFirstPackage, [4] =
    # typeOfSecondPackage, [5] = categoryNameOfSecondPackage, [6] = packageNameOfSecondPackage, [7] = tagNameOfSecondPackage, ...
    echo "${sortedPackages[@]}"  

}

# Return the array of all installed packages sorted according to
# dependencies and with removed duplicates
function getSortedArrayOfInstalledPackages(){
    
    local allPackages
    local installedPackages

    #refreshAllPackagesFromSvn notnow supress

    allPackages=(`cat $etcDir/configurations/.all | grep -v "^#" | grep -v "^$"`)
    allPackagesNumberOfElements=${#allPackages[@]}
    installedPackages=(`cat $etcDir/installed/* | grep -v "^#" | grep -v "^$" | awk '{print $3, $4}' | sort | uniq `)
    installedPackagesNumberOfElements=${#installedPackages[@]}
    local sortedPackages
    sortedPackages=()

    local rowIdx=0
    local idx=0
    while [ "$idx" -lt "$allPackagesNumberOfElements" ]
    do
      let "typeIdx = $idx"
      let "categoryIdx = $idx + 1"
      let "packageIdx = $idx + 2"
      #let "tagIdx = $idx + 3"

      #echo [$rowIdx]:   ${allPackages[$categoryIdx]} ${allPackages[$packageIdx]}
      type=${allPackages[$typeIdx]}
      category=${allPackages[$categoryIdx]}
      package=${allPackages[$packageIdx]}
      #tag=${allPackages[$tagIdx]}
      
      local j=0
      while [ "$j" -lt "$installedPackagesNumberOfElements" ]
      do
        #echo [$j]:  ${installedPackages[$j]}
        if [ "$package" = "${installedPackages[$j]}" ]; then
           let "tagIdx = $j + 1"
           tag=${installedPackages[$tagIdx]}
           #echo "update package $package from type $type in category $category. Tag: $tag" 
           sortedPackages=( "${sortedPackages[@]}" $type $category $package $tag )
           break
        fi
        let "j = $j + 2"
      done
      
      
      let "idx = $idx + 3"
      let "rowIdx = $rowIdx + 1"

    done
    # return the array of installed packages sorted according to
    # dependencies and with removed duplicates
    # This array has one dimension, but logically should be seen as 2 dimensional.
    echo "${sortedPackages[@]}"  

}


# @param $1 packageName ("" if not provided)
# @param $2 packagecategory ("" if not provided)
function updateInstalled() {

    date=$(date +"%B %d, %Y, %I:%M %p")
    echo " #-------- KARABO PACKAGE UPDATE ($date) --------#" | tee -a $etcDir/update.log

    if [[ "$1" != "" ]]; then
	local packagePath=$scriptDir/packages/$2/$1
	cd $packagePath
	echo " Update of package \"$1\" ($2)"
        echo " Update of package \"$1\" ($2):" >> $etcDir/update.log
        # this complex syntax allows us to obtain return code from svn command
        # without this syntax return code from tee would be returned
        status=`((svn update --non-interactive --accept postpone $packagePath 2>&1 3>&-; echo \$? >&3 ) | \
                          tee -a $etcDir/update.log 1>&2 1>updateStatus.tmp  3>&- ) 3>&1` 
        rm updateStatus.tmp
        
        if [ $status -ne 0 ]; then
            echo "svn update encountered some problems in $packagePath."
            exit 1
        fi
	hasConflicts=$(svn status $packagePath | grep "C       ")
	if [ "$hasConflicts" != "" ]; then
	    echo "Interrupted updating packages as the following svn conflicts have been found:"
	    echo $hasConflicts
	fi       
    else
	cd $scriptDir/packages 2>/dev/null 1>&2 
	if [ $? -ne 0 ]; then
            echo "Cannot do 'cd $scriptDir/packages', stop updating."
            return 1
	fi

	for cat in *; do
	    
	    # Skip every non-folder
	    if [ ! -d $cat ]; then
		continue
	    fi
	    
	    local categoryPath=$scriptDir/packages/$cat	    
	    cd $categoryPath
	    
	    for pck in *; do
		
		if [ ! -d $pck ]; then
		    continue
		fi
		
		local packagePath=$scriptDir/packages/$cat/$pck
		cd $packagePath
		
		echo " Update of package \"$pck\" ($cat)"
		echo " Update of package \"$pck\" ($cat):" >> $etcDir/update.log
		# this complex syntax allows us to obtain return code from svn command
		# without this syntax return code from tee would be returned
		status=`((svn update --non-interactive --accept postpone $packagePath 2>&1 3>&-; echo \$? >&3 ) | \
                          tee -a $etcDir/update.log 1>&2 1>updateStatus.tmp  3>&- ) 3>&1` 
		rm updateStatus.tmp
		
		if [ $status -ne 0 ]; then
                    echo "svn update encountered some problems in $packagePath."
                    exit 1
		fi
		hasConflicts=$(svn status $packagePath | grep "C       ")
		if [ "$hasConflicts" != "" ]; then
	            echo "Interrupted updating packages as the following svn conflicts have been found:"
	            echo $hasConflicts
	            exit 1
		fi
		
		cd $categoryPath
		
	    done
            cd $scriptDir/packages
	done
    fi
    
    echo
    echo " Update successful." 
    echo " Update information has been written to: $etcDir/update.log"
    echo
	    
}



# Rebuild all packages in a given configuration.
# Returns non-zero if any package build fails.
# @param $1 buildType [Release|Debug]
# @param $2 force [force,canSkip]
# @param $3 packageName ("" if not provided)
# @param $4 packagecategory ("" if not provided)
function rebuildInstalled() {
    buildType=$1
    force=$2
    
    if [[ "$3" != "" ]]; then
	buildPackage $3 $4 $buildType $force
	return $?
    fi

    local -i returnStatus=0

    cd $scriptDir/packages 2>/dev/null 1>&2
    if [ $? -ne 0 ]; then
        echo "Cannot do 'cd $scriptDir/packages', stop rebuilding."
        return 1
    fi

    
    for cat in *; do
	
	# Skip every non-folder
	if [ ! -d $cat ]; then
	    continue
	fi
	    
	# Skip dependency folder
	if [ "$cat" = "dependencies" ]; then
	    continue
	fi

	local categoryPath=$scriptDir/packages/$cat	    
	cd $categoryPath

	for pck in *; do
	    
	    if [ ! -d $pck ]; then
		continue
	    fi

	    #local packagePath=$scriptDir/packages/$cat/$pck

	    buildPackage $pck $cat $buildType $force        
            if [ $? -ne 0 ]; then
                returnStatus=1
            fi

	    cd $categoryPath
	    
	done
        cd $scriptDir/packages
    done
    return $returnStatus
}

# Builds a package as defined by parameters.
# Returns non-zero if any package build fails.
# @param $1 package
# @param $2 category
# @param $3 buildType [Release|Debug]
# @param $4 force [force,canSkip]
function buildPackage() {
    
    local pck=$1
    local cat=$2
    local buildType=$3
    force=n
    if [[ "x$4" == "xforce" ]]; then
        force=y
    fi

    local packagePath=$scriptDir/packages/$cat/$pck

    echo
    echo " Building package: \"$pck\""
    
    ### Check and, if necessary, build all dependecies
    
    local deps=( `getArrayOfPackageDependencies $packagePath` ) 
    local depsNumberOfElements=${#deps[@]}
    if [ $depsNumberOfElements -gt 0 ]; then		
	echo " Building dependencies for package \"$pck\" first ... " 
	echo
    else
	echo " Package \"$pck\" has no dependencies to build."
    fi
    
    
    # FIXME:
    # For now we ignore failure with dependencies below for return value!
    local idy=0
    while [ $idy -lt $depsNumberOfElements ]; do
	let "categoryIdy = $idy + 1"
	let "packageIdy = $idy + 2"
	let "tagIdy = $idy + 3"
	local packageDep=${deps[$packageIdy]}
	local categoryDep=${deps[$categoryIdy]}
	local tagDep=${deps[$tagIdy]}
	echo 
	echo  "  Building dependency package $packageDep ..."
	local packageDepPath=$scriptDir/packages/$categoryDep/$packageDep
	if [ ! -d $packageDepPath ]; then
	    echo " Dependency $packageDep for package $package doesn't exists locally"
	    echo " Checking it out ...."
	    checkoutPackage $scriptDir $packageDep $categoryDep $tagDep 0 1 $revision
	fi
	cd $packageDepPath
	if [ -e Makefile ]; then
	    if [[ "$force" == "y" ]]; then
		make clean
	    fi
	    make -j${numMakeThreads} CONF=$buildType              
	fi
	cd $scriptDir
	let "idy = $idy + 4"
    done
    
    local -i returnValue=0
    ### Build package itself
    
    cd $packagePath
    if [ -e Makefile ]; then
	if [[ "$force" == "y" ]]; then
	    make clean
	fi
	make -j${numMakeThreads} CONF=$buildType
	# link only when library.so file exist otherwise explicit '*/*' link created
	if [ $? -eq 0 ]; then
            # pluginDir should exist - but not in case of a fresh git checkout
            pluginDir=$scriptDir/servers/cppDeviceServer/plugins
            if ! takeCareDirExists $pluginDir ; then
                return 1
            fi
            cd $pluginDir
	    find $scriptDir/packages/$cat/$pck/dist/$buildType -type f \( -name \*.so -or -name \*.dylib \) -exec ln -sf {} \;
            if [ $? -ne 0 ]; then
                # failure of making the link FIXME: what if no .so exists?
                return 1
            fi
        else
            return 1  # failure of make
	fi
    else # No Makefile => This is a Python package
        # Run the package build script
        ./build-package.sh
        if [ $? -ne 0 ]; then
            return 1  # Failure
        fi
        # Install the package
        pluginDir=$scriptDir/servers/pythonDeviceServer/plugins
        if ! takeCareDirExists $pluginDir ; then
            return 1
        fi
        find package -executable -name \*.sh -exec {} --prefix=$pluginDir \;
    fi
    return 0  # looks like success...
}



function installPluginsAndDeps() {

    configurationName=$1
    buildType=$2
    force=$3

    binInstallDir=$scriptDir/pkg-bin

    pluginList="`cat $etcDir/configurations/$configurationName 2>/dev/null | grep -v "^#" | grep -v "^$" | awk '{sub(/tags\//, "", $4);sub(/branches\//, "", $4);split($4, a, "-");printf "%s %s ", $3, a[1]}'`"
    if [[ -n $pluginList ]]; then
        echo "Installing plugins: $pluginList in:"
        echo "$binInstallDir"
        echo "using karabo framework from $karaboFramework"
    fi


    depList=''

    allPlugins=($pluginList)
    allPluginsNumberOfElements=${#allPlugins[@]}
    j=0
    while [ $j -lt $allPluginsNumberOfElements ]; do
        let "nameJ = $j"
        let "versionJ = $j + 1"
        pluginName=${allPlugins[$nameJ]}
        pluginVersion=${allPlugins[$versionJ]}
        tmpDepList=''
        installPlugin tmpDepList $pluginName $pluginVersion

        #echo "tmpdeplist: $tmpDepList"
        depList="$depList $tmpDepList"
        #echo "deplist: $depList"

        let "j = $j + 2"

    done
    if [[ -n depList ]]; then
        echo "deps to be installed: $depList"
    fi
    allDeps=($depList)
    allDepsNumberOfElements=${#allDeps[@]}
    j=0
    while [ $j -lt $allDepsNumberOfElements ]; do
        let "depJ = $j"
        let "versionJ = $j + 1"
        depName=${allDeps[$depJ]}
        depVersion=${allDeps[$versionJ]}
        installDep $depName $depVersion


        let "j = $j + 2"
    done


}



pushd () {
    command pushd "$@" > /dev/null
}

popd () {
    command popd "$@" > /dev/null
}

function installPlugin () {

    _outvar=$1
    pluginName=$2
    pluginVersion=$3
    echo "Installing $pluginName $pluginVersion in $binInstallDir"


    pluginInstallScript=$pluginName-$pluginVersion-${VERSION}-${DISTRO_ID}-${DISTRO_RELEASE}-${MACHINE}.sh

    # check if installed already
    if [ -d $binInstallDir/$pluginName-$pluginVersion-${VERSION} ]; then
       echo "plugin $pluginName-$pluginVersion-${VERSION} already installed"
       eval $_outvar=''
       return 2
    fi


    getRepoList
    echo repolist: $KARABOREPOLIST
    repoList=$(fixRepoList  karabo-${VERSION} $KARABOREPOLIST)
    [ ! -d $scriptDir/downloads ] && mkdir $scriptDir/downloads 
    pushd $scriptDir/downloads
    if [ ! -e $pluginInstallScript ]; then
        getFromRepo $pluginInstallScript $repoList
        if [ $? -ne 0 ]; then
           echo "cannot get plugin installation script $pluginInstallScript from any repo"
           eval $_outvar=''
           popd
           return 1
        fi
    else
        echo "plugin $pluginInstallScript already downloaded"
    fi



    chmod +x $pluginInstallScript
    ./$pluginInstallScript --prefix=$binInstallDir

    if [ $? -ne 0 ]; then
       echo "plugin $pluginInstallScript installation error"
       eval $_outvar=''
       popd
       return 1
    fi

    popd

    if [ `find $binInstallDir/$pluginName-$pluginVersion-${VERSION} -maxdepth 1 -type f -name \*.so` ]; then
        # pluginDir should exist - but not in case of a fresh git checkout
        pluginDir=$scriptDir/servers/cppDeviceServer/plugins
        if ! takeCareDirExists $pluginDir ; then
            return 1
        fi
        ( cd $pluginDir; find $binInstallDir/$pluginName-$pluginVersion-${VERSION} -maxdepth 1  -type f -name \*.so -exec ln -sf {} \; )
    elif [ `find $binInstallDir/$pluginName-$pluginVersion-${VERSION} -maxdepth 1 -type f -name \*.py` ]; then
        # pluginDir should exist - but not in case of a fresh git checkout
        pluginDir=$scriptDir/servers/pythonDeviceServer/plugins
        if ! takeCareDirExists $pluginDir ; then
            return 1
        fi
        ( cd $pluginDir; find $binInstallDir/$pluginName-$pluginVersion-${VERSION} -maxdepth 1 -type f -not -name main.py -name \*.py -exec grep -q 'class.*(.*Python.*Device' {} \; -exec ln -sf {} \; )
    fi
    dependsPath=$binInstallDir/$pluginName-$pluginVersion-${VERSION}/DEPENDS

    #allDeps="`cat $DEPENDSPATH 2>/dev/null | grep -v "^#" | grep -v "^$" | awk '{print $3, $4}'`"
    allDeps="`cat $dependsPath 2>/dev/null | grep -v "^#" | grep -v "^$" | awk '{sub(/tags\//, "", $4);sub(/branches\//, "", $4);split($4, a, "-");printf "%s %s ", $3, a[1]}'`"
    if [[ -n $allDeps ]]; then
       echo "plugin $pluginName has deps: $allDeps"
    fi
    eval $_outvar=\$allDeps


}


function installDep () {

    depName=$1
    depVersion=$2


    depInstallScript=$depName-$depVersion-${VERSION}-${DISTRO_ID}-${DISTRO_RELEASE}-${MACHINE}.sh
    # check if already installed HOW???

    getRepoList
    repoList=$(fixRepoList  karabo-${VERSION} $KARABOREPOLIST)
    [ ! -d $scriptDir/downloads ] && mkdir $scriptDir/downloads

    pushd $scriptDir/downloads

    if [ ! -e $depInstallScript ]; then
        getFromRepo $depInstallScript $repoList
        if [ $? -ne 0 ]; then
           echo "cannot get dep installation script $depInstallScript from any repo"
           popd
           return 1
        fi
    else
        echo "dependency $depInstallScript already downloaded"
    fi
    chmod +x $depInstallScript
    ./$depInstallScript --prefix=$karaboFramework/extern

    if  [ $? -ne 0 ]; then
       echo "dep $depInstallScript installation error"
       popd
       return 1
    fi
    popd

}


function getRepoList() {
    if [ -z "$KARABOREPOLIST" ]; then
        if [ -e $HOME/.karabo/karaboRepoList ]; then
            KARABOREPOLIST=$(cat $HOME/.karabo/karaboRepoList)
        else
          echo "WARNING Could not find $HOME/.karabo/karaboRepoList. Setting default one."
          KARABOREPOLIST="http://exflserv05.desy.de/karabo/karaboPackages http://exflserv05.desy.de/karabo/karaboDependencies"
          echo $KARABOREPOLIST
          echo $KARABOREPOLIST > ${HOME}/.karabo/karaboRepoList
#          exit 1
        fi
    fi
    #repoList=$KARABOREPOLIST

}


function setRepoList() {
    defaultRepoList="http://exflserv05.desy.de/karabo/karaboPackages http://exflserv05.desy.de/karabo/karaboDependencies"
    isCorrect=1
    read -e -p "Please enter the list of url to plugins and dependencies repository [$defaultRepoList]: " user
    if [ -z "$user" ]; then
        user=$defaultRepoList
    fi
    falseRepo=''
    for repo in $user; do

        proto=${repo%%:*}
        case $proto in
            http)
            curl -Ifs -o /dev/null $repo
            if [ $? -ne 0 ];then
               isCorrect=0
               falseRepo="$falseRepo $repo"
            fi
            ;;
        ftp)
            curl -Ifs -o -u karabo:framework /dev/null $repo
            if [ $? -ne 0 ];then
               isCorrect=0
               falseRepo="$falseRepo $repo"
            fi
            ;;
        file)
            curl -Ifs -o /dev/null $repo
            if [ $? -ne 0 ];then
               isCorrect=0
               falseRepo="$falseRepo $repo"
            fi
            echo curl -f -s -O $repo/$file
            ;;
        *)
            echo $repo not supported
            isCorrect=0
            falseRepo="$falseRepo $repo"
        esac
    done


    if [[ "$isCorrect" == "0" ]]; then
        echo
        echo " URL \"$falseRepo\" not supported, could not be found or you don't have appropiate credentials."
        echo
        exit 1
    fi
    echo
    echo "The list of repositories is stored in ${HOME}/.karabo/karaboRepoList"
    echo
    echo $user > ${HOME}/.karabo/karaboRepoList

}

function fixRepoList () {

postfix=$1
shift
list="$@"
tmplist=""
for repo in $list; do
    tmplist="$tmplist $repo/$postfix"
done
echo "$tmplist"


}



function getFromRepo () {

file=$1
shift
repoList="$@"
gotFile=0
for repo in $repoList; do
    proto=${repo%%:*}
    case $proto in
        http)
            echo curl -f -s -O $repo/$file
            curl -f -s -O $repo/$file
            if [ $? -eq 0 ]; then
                gotFile=1
                echo got file
                break
            fi
            ;;
        ftp)
            echo curl -f -s -O $repo/$file
            curl -f -s -O -u karabo:framework $repo/$file
            if [ $? -eq 0 ]; then
                gotFile=1
                echo got file
                break
            fi
            ;;
        file)
            echo curl -f -s -O $repo/$file
            curl -f -s -O $repo/$file
            if [ $? -eq 0 ]; then
                gotFile=1
                echo got file
                break
            fi
            ;;
        *)
            echo $repo not supported
    esac
done
if [ $gotFile -eq 0 ]; then
    echo "file not found"
    return 1
fi



}



function refreshAllPackagesFromSvn() {

   supress=0
   if [[ $2 == "supress" ]]; then
      supress=1
   fi
   allExist=0
   delta=0
   if [ -f $etcDir/configurations/.all ]; then
      allExist=1
      OS=$(uname -s)
      if [ "$OS" = "Linux" ]; then
        modsecs=$(date --utc --reference=$etcDir/configurations/.all +%s)
        # or in this way:
        #modsecs=$(stat -c %Y $etcDir/configurations/.all)
      elif [ "$OS" = "Darwin" ]; then
        modsecs=$(stat -f %m $etcDir/configurations/.all)
      fi
      nowsecs=$(date +%s)
      delta=$(($nowsecs-$modsecs))
      #echo "File $etcDir/configurations/.all was modified $delta secs ago"
   fi
   if [[ $delta -gt 1 && $1 != "now" ]]; then
      echo
      echo "Local configuration all out of sync by `convertsecs $delta` "
      echo " Consider updating it with the command:"
      echo " $0 list refresh"
      echo
   fi
   if [[ $1 == "now" || $allExist -eq 0 ]]; then
     if [[ $supress -eq 0 ]]; then
        echo "Refreshing all configuration, please wait ..." 
        echo "# automatically created; do not edit" > $etcDir/configurations/.all
        echo "# type  category  package"   >> $etcDir/configurations/.all
     fi
     typeDevice="device"
     typeDeviceServer="deviceServer"
     typeDependency="dependency"
     typeApplication="application"

     local sortedCategories=(`svn ls $svnPath|sed -e s#\/##g|sort`)
     local sortedCategoriesNumberOfElements=${#sortedCategories[@]}
     local idx=0
     while [ "$idx" -lt "$sortedCategoriesNumberOfElements" ]
     do
       local sortedPackages=(`svn ls $svnPath/${sortedCategories[$idx]}|sed -e s#\/##g|sort`)
       local sortedPackagesNumberOfElements=${#sortedPackages[@]}
       if [[ $sortedPackagesNumberOfElements -eq 0 ]]; then
          sortedPackages=(dummy)
          sortedPackagesNumberOfElements=${#sortedPackages[@]}
       fi
       local idy=0
       while [ "$idy" -lt "$sortedPackagesNumberOfElements" ]
       do
         if [[ "${sortedCategories[$idx]}" == "dependencies" ]]; then
            echo "$typeDependency ${sortedCategories[$idx]} ${sortedPackages[$idy]}" >> $etcDir/configurations/.all
         elif [[ "${sortedCategories[$idx]}" == "deviceServers" ]]; then
            echo "$typeDeviceServer ${sortedCategories[$idx]} ${sortedPackages[$idy]}" >> $etcDir/configurations/.all
         elif [[ "${sortedCategories[$idx]}" == "testApplications" ]]; then
            echo "$typeApplication ${sortedCategories[$idx]} ${sortedPackages[$idy]}" >> $etcDir/configurations/.all
         else
            echo "$typeDevice ${sortedCategories[$idx]} ${sortedPackages[$idy]}" >> $etcDir/configurations/.all
         fi
         let "idy=$idy+1"
       done
       let "idx=$idx+1"
     done

     sortedCategories=(`svn ls $svnDepsPath|sed -e s#\/##g|sort`)
     sortedCategoriesNumberOfElements=${#sortedCategories[@]}
     idx=0
     while [ "$idx" -lt "$sortedCategoriesNumberOfElements" ]
     do
       local sortedPackages=(`svn ls $svnDepsPath/${sortedCategories[$idx]}|sed -e s#\/##g|sort`)
       local sortedPackagesNumberOfElements=${#sortedPackages[@]}
       if [[ $sortedPackagesNumberOfElements -eq 0 ]]; then
          sortedPackages=(dummy)
          sortedPackagesNumberOfElements=${#sortedPackages[@]}
       fi
       local idy=0
       while [ "$idy" -lt "$sortedPackagesNumberOfElements" ]
       do
         if [[ "${sortedCategories[$idx]}" == "dependencies" ]]; then
            echo "$typeDependency ${sortedCategories[$idx]} ${sortedPackages[$idy]}" >> $etcDir/configurations/.all
        # elif [[ "${sortedCategories[$idx]}" == "deviceServers" ]]; then
        #    echo "$typeDeviceServer ${sortedCategories[$idx]} ${sortedPackages[$idy]}" >> $etcDir/configurations/.all
        # elif [[ "${sortedCategories[$idx]}" == "testApplications" ]]; then
        #    echo "$typeApplication ${sortedCategories[$idx]} ${sortedPackages[$idy]}" >> $etcDir/configurations/.all
        # else
        #    echo "$typeDevice ${sortedCategories[$idx]} ${sortedPackages[$idy]}" >> $etcDir/configurations/.all
         fi
         let "idy=$idy+1"
       done
       let "idx=$idx+1"
     done


   fi

}


function listPackages() {
    
    refreshAllPackagesFromSvn

    echo
    echo " Existing packages (with corresponding category):"
    echo

    listAll=$1
    verbosePrint=$2

    # Retrieve available packages
    while read type category package tag
    do 
        if [[ ${type:0:1} == "#" ]]; then
            continue
        fi
        if [[ $type != "device" && $listAll -eq 0 ]]; then
            continue
        fi
        
        printf " %-20s %-20s" "$package" "($category)"
        if [[ $verbosePrint -eq 1 ]]; then
            oldSvnPath=$svnPath; if [[ "$type" == "dependency" ]]; then svnPath=$svnDepsPath; fi 
            #sortedbranches=`svn ls $svnPath/$category/$package/branches 2>/dev/null |sed -e s#\/##g|sort|tr '\n' ' '`
            sortedBranches=(`svn ls $svnPath/$category/$package/branches 2>/dev/null |sed -e s#\/##g|sort`)
            sortedBranchesListOfElements=${#sortedBranches[@]}
            #sortedtags=`svn ls $svnPath/$category/$package/tags 2>/dev/null |sed -e s#\/##g|sort|tr '\n' ' '`
            sortedTags=(`svn ls $svnPath/$category/$package/tags 2>/dev/null |sed -e s#\/##g|sort`)
            sortedTagsListOfElements=${#sortedTagsListOfElements[@]}
            svnPath=$oldSvnPath;
            local idd=0
            while [ "$idd" -lt "$sortedBranchesListOfElements" ]
            do
               printf " %-20s" "branches/${sortedBranches[$idd]}"
               let "idd=$idd+1"
            done
            local idd=0
            while [ "$idd" -lt "$sortedTagsListOfElements" ]
            do
               printf " %-20s" "tags/${sortedTags[$idd]}"
               let "idd=$idd+1"
            done
        fi
        printf "\n"
    done < $etcDir/configurations/.all
    echo
}

function listInstalledPackages() {
    
    echo
    echo " Installed packages (name, category, version):"
    echo

    cd $scriptDir/packages
    
    for cat in *; do
	
	# Skip every non-folder
	if [ ! -d $cat ]; then
	    continue
	fi
	
	local categoryPath=$scriptDir/packages/$cat	    
	cd $categoryPath
	
	for pck in *; do
	    
	    if [ ! -d $pck ]; then
		continue
	    fi
	    
	    local packagePath=$scriptDir/packages/$cat/$pck
	    cd $packagePath
	    
	    tagLocal=`svn info|grep "URL"`
	    tagLocal=`expr "$tagLocal" : '.*/\(.*/.*\)'`
	    dPart=${tagLocal%%/*}
	    vPart=${tagLocal##*/}
	    if [ "$vPart" == "trunk" ]; then
		tagLocal=trunk
	    fi

	    printf '%25s %15s %20s\n' "$pck" "$cat" "$tagLocal"
	    
	    cd $categoryPath
	    
	done
        cd $scriptDir/packages
    done
    echo
}


function listCategories() {
    
    refreshAllPackagesFromSvn

    echo
    echo " Supported categories:"
    echo
    
    listAll=$1

    # Retrieve available packages
    previousCategory=""
    while read type category package tag
    do 
        if [[ ${type:0:1} = "#" ]]; then
            continue
        fi
        if [[ $type = "dependency" && $listAll -eq 0 ]]; then
            continue
        fi
        
        if [[ "$category" != "$previousCategory" ]]; then
            echo " $category"
        fi
        previousCategory=$category
    done < $etcDir/configurations/.all
    echo
}

function listConfigurations() {
    
    echo 
    echo " Available configurations:"
    echo 
    
    cd $etcDir/configurations
    i=0
    # Parse package configurations
    for configuration in *; do
        configuration=${configuration%%.*}
	if [[ "$configuration" != "all" ]]; then
          ((i=$i+1))
          echo " ($i) $configuration"
	fi
    done
    echo
}

function listTemplates() {

    cd $etcDir/templates
    
    for templateType in *; do
        echo -e "\n  Template type: $templateType\n"
        cd $templateType
        for templateName in *; do
            echo "      $templateName"
        done
        echo
        cd ../
    done
    cd ../../
}


function listSvnSubdir() {
    local subdir=$1
    local packageName=$2
    local packageCategory=$3

    echo
    echo "  Listing svn $subdir of $packageName in $packageCategory:"
    echo

    # In case of dependencies, change svnPath temporarily to old location of dependencies
    oldSvnPath=$svnPath; if [[ "$packageCategory" == "dependencies" ]]; then svnPath=$svnDepsPath; fi
    # list the directory on the server
    svn ls $svnPath/$packageCategory/$packageName/$subdir
    echo

    # restoring previous svnPath
    svnPath=$oldSvnPath
}

function removeContinueBuildInfo() {    
   \rm $etcDir/continueBuild.info
}

function createSvnTag() {
    local packageName=$1
    local packageCategory=$2
    local svnTagFrom=$3
    local svnTagName=$4
    local svnRevFrom=${5:+ -r $5} # might not be given
    
    echo
    echo "  Creating svn tag, please wait..."
    echo
    # in case of dependencies, change svnPath temporarily to old location of dependencies
    oldSvnPath=$svnPath; if [[ "$packageCategory" == "dependencies" ]]; then svnPath=$svnDepsPath; fi
    target=$svnPath/$packageCategory/$packageName/tags/$svnTagName
    # Check non-existence of tag - otherwise source directory gets copied into it...
    svn ls $target > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "ERROR: Target tag \"$target\" already exists."
        echo "       Check tags via \"./karabo list tags $1 $2\"."
        echo
    else
        # TODO: Validate proper tag format \d\.\d\.d\-\d\.\d (e.g. 1.0.0-1.3) where
        #       the digits before '-' are the package tag and the digits after it
        #       are the karabo (branch) version.
        # '$svnTagFrom${svnRevFrom:+ $svnRevFrom}' means: if svnRevFrom non empty, add it
        svn copy --parents $svnRevFrom $svnPath/$packageCategory/$packageName/$svnTagFrom $target -m "Package $packageName got tagged from \"$svnTagFrom${svnRevFrom:+ $svnRevFrom}\" to \"tags/$svnTagName\" via karabo script"
    fi
    # restoring previous svnPath
    svnPath=$oldSvnPath
}

function createSvnBranch() {
    local packageName=$1
    local packageCategory=$2
    local svnBranchName=$3
    local svnBranchFrom=$4
    local svnRevFrom=${5:+ -r $5} # might not be given
    echo
    echo "  Creating svn branch, please wait..."
    echo
    # in case of dependencies, change svnPath temporarily to old location of dependencies
    oldSvnPath=$svnPath; if [[ "$packageCategory" == "dependencies" ]]; then svnPath=$svnDepsPath; fi
    local target="$svnPath/$packageCategory/$packageName/branches/$svnBranchName"
    # Check non-existence of branch - otherwise source directory gets copied into it...
    svn ls $target > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "ERROR: Target branch \"$target\" already exists."
        echo "       Check branches via \"./karabo list branches $1 $2\"."
        echo
    else
        # TODO: Check that svnBranchName fits branch tag format \d\.\d-\d\.\d
        #       (e.g. 1.0-1.3) where the digits before '-' are the package version
        #       branch and the digits after it are the karabo (branch) version.
        # '$svnTagFrom${svnRevFrom:+ $svnRevFrom}' means: if svnRevFrom non empty, add it
        svn copy --parents $svnRevFrom $svnPath/$packageCategory/$packageName/$svnBranchFrom $target -m "Package $packageName got branched from \"$svnBranchFrom${svnRevFrom:+ $svnRevFrom}\" to \"branches/$svnBranchName\" via karabo script"
    fi
    # restoring previous svnPath
    svnPath=$oldSvnPath
}

function detailedHelp() {
    
    if [[ "$1" == "new" ]]; then
        cat <<End-of-help
new: Create a new package in order to contribute to the development of karabo.

usage: $0 new PACKAGE_NAME PACKAGE_CATEGORY TEMPLATE_TYPE TEMPLATE_NAME CLASS_NAME [options]

PACKAGE_NAME has to be a unique (alpha-numeric, camel case) name identifying a logical set of binaries/libraries.
Already existent packages can be listed using: $0 list packages

For organizational reasons each package has to be assigned to a supported PACKAGE_CATEGORY.
Supported package categories can be listed using: $0 list categories
New category, if needed, can bew added on request.

TEMPLATE_TYPE is the type of the template to be used. Currently supported values are application, cppDevice, pythonDevice, deviceServer and dependency. 
Supported types can be listed using: $0 list templates

TEMPLATE_NAME must be a valid template name under the specified template type. 
Possible templates can be listed using: $0 list templates

CLASS_NAME, in case of device, is the name of the class which will be initially generated. Use the convention for class capitalization, 
for example: TestMessageReader, LinkedList, LinearMotor. Do not use Device in device class name, like LinearMotorDevice. 
In case af application it is the name of the source file containing main function. Use camel case names for instance: tcpClientAsync, brokerMonitor. 
In case of dependency, with template cppDep it similar as for device.  
With custom template CLASS_NAME can be set simply the same as PACKAGE_NAME

Valid options:
  -f               : forces creation of package, i.e. will overwrite in case of (locally) pre-existing packages
  -noSvn           : new package is not automatically integrated to the versioning system

Examples:

(1) Create a package for a new CPP device. The name of device is set to simulatedCamera.
$0 new simulatedCamera testDevices cppDevice minimal SimulatedCamera

(2) Create package for a new python device with minimal FSM. The name of the device is set to simulatedCamera.
$0 new simulatedCamera testDevices pythonDevice minimal SimulatedCamera

(3) Create a package dependency myDep, which is in form of a netbeans project. 
$0 new myDep dependencies dependency cppDep MyDep 

(4) Create a package dependency, (e.g. matplotlib) which must be build using custom commands.
$0 new matplotlib dependencies dependency custom matplotlib

(5) Create an application
$0 new myNewApp testApplications application defaultCpp myNewApp 


End-of-help
    elif [[ "$1" == "checkout" ]]; then
        cat <<End-of-help
checkout: Retrieve a package for editing (further development) with defined dependencies (DEPENDS file)

usage: $0 checkout PACKAGE_NAME PACKAGE_CATEGORY SVN_TAG [options]

PACKAGE_NAME and PACKAGE_CATEGORY have to be valid, and existing. Dependent packages are also automatically
checked out.

SVN_TAG is relative to the main package directory. For head revision specify "trunk".
In case of branches (or tags) use "branches/version" (or tags/version) i.e.: "branches/0.1.0" ("tags/0.1.4")

Valid options:
  -f               : forces checkout of package, i.e. will overwrite in case of (locally) pre-existing packages
  -noSvn           : package to be edited is retrieved without versioning
  -r revision      : checkout specified revision number

Examples:
(1) Checkout the HEAD revision of simulatedMotor device
    $0 checkout simulatedMotor testDevices trunk 
(2) Checkout revision 9999 of skilift device from trunk
    $0 checkout skilift testDevices trunk -r 9999

End-of-help
    elif [[ "$1" == "import" ]]; then
        cat <<End-of-help
import: import a local package to SVN, previously created with -noSvn option

usage: $0 import PACKAGE_NAME PACKAGE_CATEGORY 

PACKAGE_NAME PACKAGE_CATEGORY has to be existing locally and valid.

The cleaning of package directory is not complete, remove all not needed files before importing

Examples:
(1) import of a local simulatedMotor device
    $0 import simulatedMotor testDevices 

End-of-help

    elif [[ "$1" == "updateProject" ]]; then
        cat <<End-of-help
updateProject: update cppdevice project files in accordance to latest templates

usage: $0 updateProject PACKAGE_NAME PACKAGE_CATEGORY 

PACKAGE_NAME PACKAGE_CATEGORY has to be existing locally and valid.

Examples:
(1) update of a local simulatedMotor device
    $0 updatePackage simulatedMotor testDevices 

End-of-help

    elif [[ "$1" == "install-s" ]]; then
        cat <<End-of-help
install-s: Install a selected package configuration (from sources).

usage: install-s PACKAGE_CONFIGURATION [options]

Valid package configurations can be listed using: 
  $0 list configurations

Valid options:
  -type [Debug|Release] : the build type for the individual packages, defaults to Debug
  -force:               : existing packages will be overwritten (previous data is lost!)
             
Examples:

(1) Installation of karabo-demo packages with build type Release.
  $0 install-s karabo-demo -type Release

End-of-help

    elif [[ "$1" == "uninstall" ]]; then
        cat <<End-of-help

  Uninstall is not yet available.

End-of-help

    elif [[ "$1" == "update" ]]; then
        cat <<End-of-help
update: updates the currently installed package configurations.

usage: update [PACKAGE_NAME PACKAGE_CATEGORY]

PACKAGE_NAME PACKAGE_CATEGORY: if provided only this package will be rebuilt

Examples:

(1) Update code from repository for all packages and all dependencies
 $0 update

(2) Update only beckhoffMotor package in controlDevices category
 $0 update beckhoffMotor controlDevices

End-of-help
    
    elif [[ "$1" == "rebuild" ]]; then
        cat <<End-of-help
rebuild: rebuilds all installed packages. Dependencies of each package
 are rebuilt first, then the package itself. 

usage: rebuild [PACKAGE_NAME PACKAGE_CATEGORY] [options]

PACKAGE_NAME PACKAGE_CATEGORY: if provided only this package will be rebuilt

Valid options:
  -type [Debug|Release] : the build type for the individual packages, defaults to Debug 
  -force : rebuild even if there are no local modifications (runs make clean)

Examples:
 
(1) Rebuild all installed packages with their dependencies. If actual recompilation
    takes place depends on local modifications (make)
 $0 rebuild
  
(2) Rebuild all installed packages with their dependencies regardless of local modifications
 $0 rebuild -force

(3) Rebuild all installed packages with their dependencies regardless of local modifications in "Release" mode
 $0 rebuild -force -type Release

(4) Rebuild package "helloWorld" of category "testDevices"
 $0 rebuild helloWorld testDevices

End-of-help
        
    elif [[ "$1" == "list" ]]; then
        cat <<End-of-help
list: Create listings of various type

usage: list DETAIL  [options] 

  DETAIL may be one of the following options:

  packages       - Lists all available packages (devices)
           options:  -a  list all available packages (devices, dependencies, ...)
                     -v  verbose listing - includes available versions (branches and tags) (experimental)
  installed      - Lists all packages within installed configurations
  categories     - Lists all supported categories (i.e. package groupings)
  configurations - Lists all configurations (logical package subsets)
  templates      - Lists all available templates
  refresh        - Refreshes list from svn
  tags           - Lists existing tags of given package
  branches       - Lists existing branches of given package

Examples:

(1) List all available package configurations
  $0 list configurations

(2) List all installed packages within all installed configurations
  $0 list installed

(3) List all available packages of device type (plugins)
  $0 list packages

(4) List all available packages regardless of their type
  $0 list packages -a

(5) List existing tags of a package
  $0 list tags PACKAGE_NAME PACKAGE_CATEGORY

(6) List existing branches of a package
  $0 list branches PACKAGE_NAME PACKAGE_CATEGORY

End-of-help

    elif [[ "$1" == "tag" ]]; then
        cat <<End-of-help
tag: Create an svn tag of a package

usage: tag PACKAGE_NAME PACKAGE_CATEGORY TAG_FROM TAG_NAME [REVISION_FROM]

Examples:

(1) Tag new development from trunk
  $0 tag beckhoffCom controlDevices trunk 0.1.0-1.2

(2) Tag from an existing tag indicating validity for a new Karabo version
  $0 tag beckhoffCom controlDevices tags/0.1.0-1.2 0.1.0-1.3

(3) Tag from an svn revision of a branch for bug fixes or backports
  $0 tag beckhoffCom controlDevices branches/0.1-1.2 0.1.1-1.2 4567

End-of-help

    elif [[ "$1" == "branch" ]]; then
        cat <<End-of-help
branch: Create an svn branch of a package

usage: branch PACKAGE_NAME PACKAGE_CATEGORY BRANCH_NAME [FROM [REVISION_FROM]]

If the optional FROM is not given, trunk is used. If REVISION_FROM is not given,
use HEAD.

Examples:

(1) Branch from current trunk:
  $0 branch conveyor testDevices 1.0-1.3

(2) Branch from specific version of trunk:
  $0 branch conveyor testDevices 1.0-1.3 trunk 5432

(3) Branch from an existing tag:
  $0 branch conveyor testDevices 1.0-1.3 tags/1.0.0-1.3

End-of-help

    elif [[ "$1" == "setsvn" ]]; then
        cat <<End-of-help
setsvn: sets interactively svn path to KaraboPackages and karabo dependencies repositories

usage: setsvn   (then press Enter to get default paths)

End-of-help

    elif [[ "$1" == "setrepo" ]]; then
        cat <<End-of-help
setrepo: sets interactively url list to binary repositories containing installation scripts for plugins and dependencies

usage: setrepo   (press Enter to get default list)

Examples: this urls can be used:  http://, ftp://, file://
          http://exflserv05.desy.de/karabo/karaboPackages
          ftp://ftp.desy.de/karaboPackages
          file:///local/path/to/repository
End-of-help

    fi
    exit 0
}


#############################
#        Script start       #
#############################

# check if email address is defined in [home directory]/.karabo/email and if not ask user to provide it
getEmail

# check if path to Karabo framework is set
getKaraboFramework

# check env variable KARABOSVNPATH or $HOME/.karabo/karaboSvnPath, otherwise set to default 
#svnPath=https://svnsrv.desy.de/desy/EuXFEL/WP76/karabo/karaboPackages
getSvnPath

if [[ -z "$1" ||  $1 = "help" || $1 = "-h" ||  $1 = "-help" ]]; then

    if [ ! -z "$2" ]; then
        detailedHelp $2
    fi

    cat <<End-of-help
usage: $0 <subcommand> [options] 

Type '$0 help <subcommand>' for help on a specific command

Available subcommands:

  install-b - Install a package configuration (download binary)
  install-s - Install a package configuration (build from sources)
  update    - Update (svn) installed packages
  rebuild   - Rebuild installed packages
  new       - Create a new package
  checkout  - Checkout an existing package (use list to retrieve name)
  list      - Create listings of various type
  tag       - Creates a svn tag for a given package
  branch    - Creates a svn branch for a given package
  setsvn    - Sets karabo svn repository path
  setrepo   - Sets url list to binary repositories
  import    - Imports local project into repository 

End-of-help

    exit 0
fi
    

#############################
#     Parse commandline     #
#############################
until [ -z "$1" ]; do
    
    # Interactive mode
    if [ $1 = "-i" ]; then
        selectAction
        break

    # New package
    elif [ $1 = "new" ]; then
        new=1
        if [ $# -lt 6 ]; then
            detailedHelp $1
        fi
        packageName=$2
        packageCategory=$3
        templateType=$4
	    templateName=$5
	    moduleName=$6

        shift; shift; shift; shift; shift;shift
        until [ -z "$1" ]; do
            lower=$(toLower $1)
            if [[ "${lower:0:1}" == "-" ]]; then
                if [ $lower = "-f" ]; then
                    force=1
                elif [ $lower = "-nosvn" ]; then
                    isSvn=0
                else
                    echo " Unrecognized option: $1"
                    exit 1;
                fi
            else
               echo " Unrecognized option: $1"
               exit 1;
            fi
            shift
        done

    # Checkout package
    elif [ $1 = "checkout" ]; then
        checkout=1
        if [ $# -lt 4 ]; then
            detailedHelp $1
        fi
        packageName=$2
	packageCategory=$3
	tag=$4
        shift; shift; shift; shift
        until [ -z "$1" ]; do
            lower=$(toLower $1)
            if [[ "${lower:0:1}" == "-" ]]; then
                if [ $lower = "-f" ]; then
                    force=1
                elif [ $lower = "-nosvn" ]; then
                    isSvn=0
                elif [ $lower = "-r" ]; then
                    revision=$2
                    shift
                else
                    echo " Unrecognized option: $1"
                    exit 1;
                fi
            else
               echo " Unrecognized option: $1"
               exit 1;
            fi
            shift
        done

    # import package
    elif [ $1 = "import" ]; then
        import=1
        if [ $# -lt 3 ]; then
            detailedHelp $1
        fi
        packageName=$2
	packageCategory=$3
        shift; shift; shift

    # update project files
    elif [ $1 = "updateProject" ]; then
        updateProjectFiles=1
        if [ $# -lt 3 ]; then
            detailedHelp $1
        fi
        packageName=$2
        packageCategory=$3
        shift; shift; shift


    # Install package configuration (sources)
    elif [ $1 = "install-s" ]; then
        install_s=1
        if [ $# -lt 2 ]; then
            detailedHelp $1
        elif [ $2 = "help" ]; then
            detailedHelp $1
        fi
        configurationName=$2
	if [[ "$configurationName" == "all" ]]; then
            echo " $configurationName configuration is not supported"
            exit 1
	fi
        shift;
        until [ -z "$2" ]; do
            if [[ "$2" == "-type" ]]; then
                if [ -z "$3" ]; then
                    echo " Missing option, expecting either Debug or Release"
                    exit 1
                fi
                buildType=$3;
                echo "Build Type: $buildType"
                # valid options
                if [[ "$buildType" != "Debug" && "$buildType" != "Release" ]]; then
                    echo " Invalid option: \"$3\", expecting either Debug or Release"
                    exit 1
                fi
                shift; shift
	    elif [[ "$2" == "-force" ]]; then
                forceInstallation="1"
                shift
            else
                echo " Invalid option: \"$2\""
                detailedHelp "install-s"
            fi
        done
        shift
    # Install package configuration (binary)
    elif [ $1 = "install-b" ]; then
        install_b=1
        if [ $# -lt 2 ]; then
            detailedHelp $1
        elif [ $2 = "help" ]; then
            detailedHelp $1
        fi
        configurationName=$2
	if [[ "$configurationName" == "all" ]]; then
            echo " $configurationName configuration is not supported"
            exit 1
	fi
        shift;
        until [ -z "$2" ]; do
            if [[ "$2" == "-type" ]]; then
                if [ -z "$3" ]; then
                    echo " Missing option, expecting either Debug or Release"
                    exit 1
                fi
                buildType=$3;
                echo "Build Type: $buildType"
                # valid options
                if [[ "$buildType" != "Debug" && "$buildType" != "Release" ]]; then
                    echo " Invalid option: \"$3\", expecting either Debug or Release"
                    exit 1
                fi
                shift; shift
	    elif [[ "$2" == "-force" ]]; then
                forceInstallation="1"
                shift
            else
                echo " Invalid option: \"$2\""
                detailedHelp "install-s"
            fi
        done
        shift
    # Update packages
    elif [ $1 = "update" ]; then
        update=1
	if [ -n "$2" ]; then
	    if [ -z "$3" ]; then
		echo " Missing option: expecting PACKAGE_CATEGORY"
		exit 1
	    fi
	    packageName=$2
	    packageCategory=$3
	    shift; shift
	fi
	shift
    # Rebuild suite
    elif [ $1 = "rebuild" ]; then
        rebuild=1
        if [ "$2" = "help" ]; then
            detailedHelp $1
        fi
        until [ -z "$2" ]; do
            if [[ "$2" == "-type" ]]; then
                if [ -z "$3" ]; then
                    echo " Missing option, expecting either Debug or Release"
                    exit 1
                fi
                buildType=$3;
                echo "Build Type: $buildType"
                # valid options
                if [[ "$buildType" != "Debug" && "$buildType" != "Release" ]]; then
                    echo " Invalid option: \"$3\", expecting either Debug or Release"
                    exit 1
                fi
                shift; shift
            elif [[ "$2" == "-force" ]]; then
                forceRebuild="force"
                shift
            else 
		if [ -z "$3" ]; then
		    echo " Missing option: expecting PACKAGE_CATEGORY"
		    exit 1
		fi
                packageName=$2
		packageCategory=$3
		shift; shift
            fi
        done
        shift
    # Uninstall package    
    elif [ $1 = "uninstall" ]; then
        uninstall=1
        shift

    # List all available packages
    elif [ $1 = "list" ]; then
        list=1
        if [ $# -lt 2 ]; then
            detailedHelp $1
        elif [ $2 = "help" ]; then
            detailedHelp $1
        fi
        listWhat=$2
        # listing tags and branches needs further arguments:
        if [ $listWhat == "tags" ] || [ $listWhat == "branches" ]; then
           if [ $# -lt 4 ]; then
             detailedHelp $1
           else
             packageName=$3
             packageCategory=$4
             shift; shift
           fi
        fi
        shift; shift
        until [ -z "$1" ]; do
            if [[ "$1" == "-a" ]]; then
                allList=1
            elif [[ "$1" == "-v" ]]; then
                verboseList=1
            else
                echo "invalid option, expecting -a or -v "
                exit 1
            fi
            shift
        done
        
    # Create a tag
    elif [ $1 = "tag" ]; then
        createTag=1
        if [ $# -lt 5 ]; then
            detailedHelp $1
        else
            packageName=$2
            packageCategory=$3
            svnTagFrom=$4
            svnTagName=$5
            if [ $# -ge 6 ]; then
		tagBranchFromRev=$6
		shift
	    fi
            shift; shift; shift; shift; shift
        fi

    # Create a branch
    elif [ $1 = "branch" ]; then
        createBranch=1
        if [ $# -lt 4 ]; then
            detailedHelp $1
        else
            packageName=$2
            packageCategory=$3
            svnBranchName=$4
            if [ $# -ge 5 ]; then
		svnBranchFrom=$5
                if [ $# -ge 6 ]; then
		    tagBranchFromRev=$6
		    shift
	        fi
		shift
	    fi
            shift; shift; shift; shift
        fi

    # Set svn path
    elif [ $1 = "setsvn" ]; then
        setSvn=1
        shift
    # Set repository list
    elif [ $1 = "setrepo" ]; then
        setRepo=1
        shift
    else
        echo "  Invalid option: $1"
        exit 1
    fi
done

#############################
#         Logic             #
#############################

if [[ "$forget" == "1" ]]; then
    removeContinueBuildInfo
elif [[ "$install_s" == "1" ]]; then
    installConfiguration $configurationName $buildType $forceInstallation
elif [[ "$install_b" == "1" ]]; then
    installPluginsAndDeps $configurationName $buildType $forceInstallation

elif [[ "$update" == "1" ]]; then
    updateInstalled $packageName $packageCategory
    
elif [[ "$list" == "1" ]]; then
    if [[ "$listWhat" == "packages" ]]; then
        listPackages $allList $verboseList
    elif [[ "$listWhat" == "installed" ]]; then
        listInstalledPackages 
    elif [[ "$listWhat" == "categories" ]]; then
        listCategories $allList
    elif [[ "$listWhat" == "configurations" ]]; then
        listConfigurations
    elif [[ "$listWhat" == "templates" ]]; then
        listTemplates
    elif [[ "$listWhat" == "refresh" ]]; then
        refreshAllPackagesFromSvn now
    elif [[ "$listWhat" == "tags" ]]; then
        listSvnSubdir tags $packageName $packageCategory
    elif [[ "$listWhat" == "branches" ]]; then
        listSvnSubdir branches $packageName $packageCategory
    fi

elif [[ "$new" == "1" ]]; then
    validateNewPackage $packageName $packageCategory
    setupNewPackage $packageDevPath $packageCategory $packageName $templateType $templateName $moduleName $force $isSvn

elif [[ "$checkout" == "1" ]]; then
    checkoutPackage $packageDevPath $packageName $packageCategory $tag $force $isSvn $revision

elif [[ "$import" == "1" ]]; then
    importPackage $packageDevPath $packageName $packageCategory $tag

elif [[ "$rebuild" == "1" ]]; then
    rebuildInstalled $buildType $forceRebuild $packageName $packageCategory

elif [[ "$createTag" == "1" ]]; then
    createSvnTag $packageName $packageCategory $svnTagFrom $svnTagName $tagBranchFromRev

elif [[ "$createBranch" == "1" ]]; then
    createSvnBranch $packageName $packageCategory $svnBranchName $svnBranchFrom $tagBranchFromRev
elif [[ "$setSvn" == "1" ]]; then
    setSvnPath
elif [[ "$setRepo" == "1" ]]; then
    setRepoList
elif [[ "$updateProjectFiles" == "1" ]]; then
    updateProject $packageDevPath $packageName $packageCategory 

fi


