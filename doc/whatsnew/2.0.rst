************************
What's New in Karabo 2.0
************************

Karabo now uses C++11 features
==============================

While the code of C++11 devices does not have to change to profit from some
optimizations that C++11 provides, the compiler flags generated by NetBeans 
have to be adjusted. To do so

* open your package in NetBeans,
* right-click ion the package in the project panel,
* choose the last entry in the appearing menu ("Properties"),
* in the appearing dialogue,

     *choose "Build -> C++ compiler" in the "Categories" panel on the left,
     *"<All Configurations>" in the for "Configurations" on the top
     * and "C++11" for "C++ Standard" in the options field.

Compile from NetBeans once in "Release" and once in "Debug" mode and commit the
following new files in the `nbproject` directory:

* configurations.xml
* Karabo-Debug-Linux.mk
* Karabo-Release-Linux.mk

Update Makefile
+++++++++++++++

To take care that the changes of the NetBeans generated makefiles will be  
properly updated also there where the device project was only checked out  
and compiled from the command line, the package `Makefile` has to be updated 
as well. This updates fixes tiny makefile bugs as have been fixed in the  
framework long ago.

Some macro changes (C++)
========================

To make a member function callable as a slot, do not use anymore the 
`SLOT<N>` macros but switch to used `KARABO_SLOT<N>`.

Alarm Conditions
================

Alarm conditions are now based on objects. There is a predefined set of
conditions. In C++ they can be found in::

   karabo::util::AlarmCondition

in Python in::

   karabo.bound.AlarmCondition

The following conditions now exist: `NONE, WARN, ALARM, INTERLOCK`. Conditions
 `WARN` and `ALARM` are further specialized into
`WARN_LOW, WARN_HIGH, ALARM_LOW, ALARM_HIGH, WARN_VARIANCE_LOW`, 
`WARN_VARIANCE_HIGH, ALARM_VARIANCE_LOW, ALARM_VARIANCE_HIGH`.

Additionally, a new property `alarmCondition` has been added to the base
device  classes in both APIs. It holds the defining alarm condition of an
device:


* it evaluates to the most critical of all the property bound alarm conditions:

  `INTERLOCK>ALARM>WARN>NONE`

* unless a device developer manually set the alarmCondition field via
  `setAlarmCondition(AlarmCondition condition)`. In this case this alarm
  condition is maintained if property conditions evaluate to a lower combined
  condition. This especially means that a manually set alarm condition will
  not automatically clear, it needs to be cleared using
  `setAlarmCondition(AlarmCondition::NONE)`.  It may however be raised by the
   property bound conditions.

In addition the expected parameter interface was slightly altered.
Previously existing attributes::

  .alarmLow, .alarmHigh, .warnLow, .warnHigh

now have to be followed by `.needsAcknowledging(true | false)` indicating  if
the alarm needs to be acknowledged on the alarm service device. Optionally,
they may be followed first by `.info(string)`, giving more information
on an alarm.


Additionally, variance base alarms are now supported. They can be enabled for
readonly parameters via::

  .enableRollingStats()


followed by the conditions::

  .alarmVarianceLow, .alarmVarianceHigh, .warnVarianceLow, .warnVarianceHigh


each again optionally followed by `.info` and mandatorily by
`.needsAcknowledging`.

The `.enableRollingStats` block is closed of by
`.evaluationInterval(interval)`, which gives the size of the rolling window.

Rolling statistics can accessed from device code for those properties they
have been enabled for via `getRollingStatistics(path)`. This returns a object
of type RollingWindowStatistics, with methods::

  update(val)
  getRollingWindowVariance()
  getRollingWindowMean()

If a property has rolling statistics enable may be queried via
`hasRollingStatistics()` from the device.


Device States
=============

The states in which a device can be, have now to be chosen from a list of
states that Karabo provides. Both in C++ and Python, the allowed states are
represented by an object of the class `State`. The specific states are accessed
 via that class as well, i.e. for the `INIT` state one just uses `State::INIT`
  in C++ and `State.INIT` in Python (both bound and middlelayer).

The list of available states can e.g. be looked in :ref:`karabo::util::States`

Defining the List of States for a Specific Device
+++++++++++++++++++++++++++++++++++++++++++++++++

For both bound Python and C++, the code to define the list of allowed states
in the `expectedParameters` function looks almost identical, e.g. for bound
Python it is::

    OVERWRITE_ELEMENT(expected).key("state")
        .setNewOptions(State.INIT, State.STOPPED, State.STARTED, State.ERROR)
        .setNewDefaultValue(State.INIT)
        .commit(),

and in C++ the '.' between `State` and the state name has to be
replaced by '::'.

Defining Allowed States for Actions
+++++++++++++++++++++++++++++++++++

Similarly, one defines the list of `allowedStates` for reconfigurable
configuration parameters and for slots via::

    .allowedStates(State.STOPPED, State.STOPPING)


Accessing and Updating the States
+++++++++++++++++++++++++++++++++

To access the current state of a device, use its `getState` method in C++ or
simple `self.get("state")` in bound python.

The interface to update the state (needed only if using the default `NoFsm`)
of a device has changed to take a `State` object as argument,
e.g. `self.updateState(State.HOMING)` and `this->updateState(State::HOMING)`,
respectively.


Python Entry Point
==================

The `setup.py` file in Python packages defines "entry points". The values of
them differs for bound and middlelayer Python devices. These entry points
have been renamed and the `setup.py` file has to be adjusted accordingly:

* Bound Python: from `karabo.python_device.api_1` to `karabo.bound_device`
* Middlelayer Python: from `karabo.python_device.api_2` to
  `karabo.middlelayer_device`

Bound Python
============

Vector elements
+++++++++++++++

It is not possible anymore to directly assign a `numpy.array` to a
`VECTOR_ELEMENT`. Instead, the `numpy.array` has to be converted to a `list`
or `tuple`, e.g.::


    array = numpy.array(...)
    self["vectorProperty"] = array.tolist()


Pipelined processing
====================

The pipelined processing, i.e. the data flow between `InputChannel` and
`OutputChannel`, has been redesigned with several interface simplifications.

Removal of `Data` class, image and array handling
+++++++++++++++++++++++++++++++++++++++++++++++++

In the past, data was passed as a `Data` object. This class has been removed
and data is now sent as a usual `Hash`. Also the classes to pass
multidimensional arrays and images have been re-desigend. In the past,
they inherited from `Data`, but now they look like standalone classes.
Whereas in the past `ImageData` inherited from `NDArray`, now it has an
`NDArray`. How to construct objects of these classes (e.g. to avoid copies)
can be found in the API documentation. Here is an example how to declare
an output channel to send image data and a frame number in Python:

Define output::

    def expectedParameters(expected):
       ...
        data = Schema()
        (
        IMAGEDATA_ELEMENT(data)
            .key("image")
            .commit()
        UINT32_ELEMENT(data)
            .key("frame")
            .readOnly()
            .commit()
        )
        (
        OUTPUT_CHANNEL(expected).key("output")
            .displayedName("Output")
            .dataSchema(data)
            .commit()
         )


Send data in a device slot::

    imgArray = numpy.array(...)
    self.writeChannel("output", Hash("image", ImageData(imgArray),
                                             "frame", frameNumber))


KARABO_ON_INPUT handlers
++++++++++++++++++++++++

If your device registered a handler that receives an `InputChannel` as argument
via the `KARABO_ON_INPUT` (and the `KARABO_ON_DATA`) macro, do **not** call
`update()` on the `InputChannel` anymore.

