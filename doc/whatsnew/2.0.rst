************************
What's New in Karabo 2.0
************************

Karabo now uses C++11 features
==============================



C++11 usage is now (officially) supported for framework code. The following
guidelines are suggested:

- Feel free to use new features where they make sense. E.g. use auto to shorten
  iterator syntax in loops, e.g.
  `std::map<MyComplexType, MyMoreComplexType<double> >::const_iterator it = foo.begin() -> auto it = foo.begin()`.

- Don’t use `auto` to indicate straight forward types, e.g. `auto i = 4;`

- Existing code does not need to be refactored for C++11 feature usage alone.
  E.g. if you happen to refactor something anyway, feel free to replace iterators
  with `auto` if it aids readability. You do not specifically have to refactor
  otherwise working code though.

- Do **not** use `std::shared_ptr`, we will continue to use `boost::shared_ptr`!

- In general, if a `boost` and a `std`-library feature coexist
  (smart pointers, mutices, bind, etc.), continue to use the boost implementation
  as we have done previously, especially if there is a risk that your new code
  needs to interact with existing code.

- When using more „advanced“ features, like late return type declaration
  (`->decltype(foo)`), variadic templates or reference forwarding, add a short
  comment to these lines to aid people less experienced with C++11 features in
  the review.

- We currently do not encourage to use newly introduced numerical types, e.g.
  `uint64_t` as the Karabo type system has not been fully prepared for them.

Compiling devices with C++11 support
++++++++++++++++++++++++++++++++++++

While the code of C++11 devices does not have to change to profit from some
optimizations that C++11 provides, the compiler flags generated by NetBeans 
have to be adjusted. To do so

* open your package in NetBeans,
* right-click ion the package in the project panel,
* choose the last entry in the appearing menu ("Properties"),
* in the appearing dialogue,

     *choose "Build -> C++ compiler" in the "Categories" panel on the left,
     *"<All Configurations>" in the for "Configurations" on the top
     * and "C++11" for "C++ Standard" in the options field.

Compile from NetBeans once in "Release" and once in "Debug" mode and commit the
following new files in the `nbproject` directory:

* configurations.xml
* Karabo-Debug-Linux.mk
* Karabo-Release-Linux.mk



Update Makefile
+++++++++++++++

To take care that the changes of the NetBeans generated makefiles will be  
properly updated also there where the device project was only checked out  
and compiled from the command line, the package `Makefile` has to be updated 
as well. This updates fixes tiny makefile bugs as have been fixed in the  
framework long ago.

Some macro changes (C++)
========================

To make a member function callable as a slot, do not use anymore the 
`SLOT<N>` macros but switch to used `KARABO_SLOT<N>`.

Alarm Conditions
================

Alarm conditions are now based on objects. There is a predefined set of
conditions. In C++ they can be found in::

   karabo::util::AlarmCondition

in Python in::

   karabo.bound.AlarmCondition

The following conditions now exist: `NONE, WARN, ALARM, INTERLOCK`. Conditions
 `WARN` and `ALARM` are further specialized into
`WARN_LOW, WARN_HIGH, ALARM_LOW, ALARM_HIGH, WARN_VARIANCE_LOW`, 
`WARN_VARIANCE_HIGH, ALARM_VARIANCE_LOW, ALARM_VARIANCE_HIGH`.

Additionally, a new property `alarmCondition` has been added to the base
device  classes in both APIs. It holds the defining alarm condition of an
device:


* it evaluates to the most critical of all the property bound alarm conditions:

  `INTERLOCK>ALARM>WARN>NONE`

* unless a device developer manually set the alarmCondition field via
  `setAlarmCondition(AlarmCondition condition)`. In this case this alarm
  condition is maintained if property conditions evaluate to a lower combined
  condition. This especially means that a manually set alarm condition will
  not automatically clear, it needs to be cleared using
  `setAlarmCondition(AlarmCondition::NONE)`.  It may however be raised by the
   property bound conditions.

In addition the expected parameter interface was slightly altered.
Previously existing attributes::

  .alarmLow, .alarmHigh, .warnLow, .warnHigh

now have to be followed by `.needsAcknowledging(true | false)` indicating  if
the alarm needs to be acknowledged on the alarm service device. Optionally,
they may be followed first by `.info(string)`, giving more information
on an alarm.


Additionally, variance base alarms are now supported. They can be enabled for
readonly parameters via::

  .enableRollingStats()


followed by the conditions::

  .alarmVarianceLow, .alarmVarianceHigh, .warnVarianceLow, .warnVarianceHigh


each again optionally followed by `.info` and mandatorily by
`.needsAcknowledging`.

The `.enableRollingStats` block is closed of by
`.evaluationInterval(interval)`, which gives the size of the rolling window.

Rolling statistics can accessed from device code for those properties they
have been enabled for via `getRollingStatistics(path)`. This returns a object
of type RollingWindowStatistics, with methods::

  update(val)
  getRollingWindowVariance()
  getRollingWindowMean()

If a property has rolling statistics enable may be queried via
`hasRollingStatistics()` from the device.


Device States
=============

The states in which a device can be, have now to be chosen from a list of
states that Karabo provides. Both in C++ and Python, the allowed states are
represented by an object of the class `State`. The specific states are accessed
 via that class as well, i.e. for the `INIT` state one just uses `State::INIT`
  in C++ and `State.INIT` in Python (both bound and middlelayer).

The list of available states can e.g. be looked in :ref:`karabo::util::States`

Defining the List of States for a Specific Device
+++++++++++++++++++++++++++++++++++++++++++++++++

For both bound Python and C++, the code to define the list of allowed states
in the `expectedParameters` function looks almost identical, e.g. for bound
Python it is::

    OVERWRITE_ELEMENT(expected).key("state")
        .setNewOptions(State.INIT, State.STOPPED, State.STARTED, State.ERROR)
        .setNewDefaultValue(State.INIT)
        .commit(),

and in C++ the '.' between `State` and the state name has to be
replaced by '::'.

Defining Allowed States for Actions
+++++++++++++++++++++++++++++++++++

Similarly, one defines the list of `allowedStates` for reconfigurable
configuration parameters and for slots via::

    .allowedStates(State.STOPPED, State.STOPPING)


Accessing and Updating the States
+++++++++++++++++++++++++++++++++

To access the current state of a device, use its `getState` method in C++ or
simple `self.get("state")` in bound python.

The interface to update the state (needed only if using the default `NoFsm`)
of a device has changed to take a `State` object as argument,
e.g. `self.updateState(State.HOMING)` and `this->updateState(State::HOMING)`,
respectively.


Python Entry Point
==================

The `setup.py` file in Python packages defines "entry points". The values of
them differs for bound and middlelayer Python devices. These entry points
have been renamed and the `setup.py` file has to be adjusted accordingly:

* Bound Python: from `karabo.python_device.api_1` to `karabo.bound_device`
* Middlelayer Python: from `karabo.python_device.api_2` to
  `karabo.middlelayer_device`

Bound Python
============

Vector elements
+++++++++++++++

It is not possible anymore to directly assign a `numpy.array` to a
`VECTOR_ELEMENT`. Instead, the `numpy.array` has to be converted to a `list`
or `tuple`, e.g.::


    array = numpy.array(...)
    self["vectorProperty"] = array.tolist()


Pipelined processing
====================

The pipelined processing, i.e. the data flow between `InputChannel` and
`OutputChannel`, has been redesigned with several interface simplifications.

Removal of `Data` class, image and array handling
+++++++++++++++++++++++++++++++++++++++++++++++++

In the past, data was passed as a `Data` object. This class has been removed
and data is now sent as a usual `Hash`. Also the classes to pass
multidimensional arrays and images have been re-desigend. In the past,
they inherited from `Data`, but now they look like standalone classes.
Whereas in the past `ImageData` inherited from `NDArray`, now it has an
`NDArray`. How to construct objects of these classes (e.g. to avoid copies)
can be found in the API documentation. Here is an example how to declare
an output channel to send image data and a frame number in Python:

Define output::

    def expectedParameters(expected):
       ...
        data = Schema()
        (
        IMAGEDATA_ELEMENT(data)
            .key("image")
            .commit()
        UINT32_ELEMENT(data)
            .key("frame")
            .readOnly()
            .commit()
        )
        (
        OUTPUT_CHANNEL(expected).key("output")
            .displayedName("Output")
            .dataSchema(data)
            .commit()
         )


Send data in a device slot::

    imgArray = numpy.array(...)
    self.writeChannel("output", Hash("image", ImageData(imgArray),
                                             "frame", frameNumber))


KARABO_ON_INPUT handlers
++++++++++++++++++++++++

If your device registered a handler that receives an `InputChannel` as argument
via the `KARABO_ON_INPUT` (and the `KARABO_ON_DATA`) macro, do **not** call
`update()` on the `InputChannel` anymore.


Checklist for basic Karabo 2.0 Compatability
============================================

The following checklist gives guidance if you have considered significant
changes when updating your device code. This does not mean that your device
follows all 2.0 best practices - it simply will run.

General
+++++++

- Replaced string states with unified states in all occurances
- Make sure the logger is not used to indicate alarms, use alarm conditions
  instead
- Adapted any pipelined processing so that handlers take meta data as second
  argument
- Replace all occurances of `XXX_PTR` and `MATRIX_XXX` with `NDARRAY`
- Replace `KARABO_GLOBAL_SLOT(...)` with `KARABO_SLOT("*", ...)`
- Make sure that if you are using devices, device servers or signal slottable
  outside the usual, device-server hosted context, that you start an event loop
  and an event loop work thread before.

C++ - Specific
++++++++++++++

- Update your Netbeans project to compile using C++11

Python Bound - Specific
+++++++++++++++++++++++

- Verify entry points are correctly set in setup.py
- Batch replace and `self._ss` calls with `self`. If you get failures afterwards
  you are using the private interface of signal slotable and should contact
  a system architect

Python Middlelayer - Specific
+++++++++++++++++++++++++++++

- Make yourself familiar with the new unified sync/async interface
- Update to `DeviceNodes` whenever you have explicitly used `connectDevice`
  to mirror properties of a remote device in your expected parameters.

